Ganymede Developer Release 0.99.9
January 13, 2000
THINGSTODO
---------------------------------------------

0) Schema Kit Separation, Upgrade Support

I've done some more thinking about separating out schema
kits from the Ganymede distribution to allow people to build
and distribute schema kits separate from the Ganymede server,
but I keep running into issues with upgrades.

What comes to mind is that it would be nice to allow database schemas
to be updated and then folded into adopters' existing ganymede.db
files.  I'm thinking that with a nice XML parser, I could provide
support for taking an existing ganymede.db file and a new schema file
(ganymede.schema.xml?) and have the Ganymede server take a look at the
new schema description and integrate the changes into the existing
ganymede.db file if the changes were not incompatible.

This is an awfully big change to pull (putting xml support into the
ganymede server and schema editor), and at this point I don't have any
work done towards it.  There were enough performance and stability
changes queued up that I thought I'd go ahead and release 0.99.9
without doing anything on schema kit separation, but I still believe
this needs to be done.  Somehow.

..

I keep putting off doing this, but I really do need to rework
the way schema kits are packaged and distributed with Ganymede,
to make it easier for people to do schema kit maintenance.

I'm going to really try to make this the focus for 0.99.9.

..

For 0.99.8 I'm planning on reworking how schema kits are packaged and
installed, to make it possible to maintain and distribute schema kits
separate from the main Ganymede distribution.  This will involve
changes to various elements of the distribution.  The most likely
outcome of these changes will be that schema kit developers will write
a custom Perl5 module that will get invoked by the installServer
script to tie the schema kit's configuration and installation into the
standard server install process.  Alternately, a free-standing and
standard installSchema script will be able to use the same
customization module to install a new schema kit into a pre-existing
server installation.

1) DNS Support

The biggest point to make about Ganymede right now is that it is as
much a framework for you to build management software with as it is a
finished product.  In particular, while the gasharl, linux, and bsd
schemas are in decent shape, you have to either already be using GASH
or be willing to settle for simple user/group management if you aren't
willing to do some work to develop a schema that is useful for you.

What is really needed is for someone to develop a generic DNS schema
kit that includes a good general parser for DNS files.  The gasharl
schema is designed to support a single comprehensive NIS domain and a
single DNS domain broken into Class-C sized subnets, but it is
designed to work with files generated/maintained by GASH.

Bootstrapping a DNS management system from zone files needs to be
supported, but Ganymede's objects and links model makes this process
of doing this a bit unobvious.  The gasharl schema uses system
information where all the interfaces and system information for
individual systems is grouped together in objects.  For our network,
this information was collated and assembled by hand.  Hopefully
there's a good way of avoiding that work.

Right now the gasharl schema kit is the most fully developed and
tested schema, but the gasharl schema kit does not include a full
and working NIS/DNS build system.

We are currently developing enhanced DNS support through the use of an
XML layer to replace the old gash hosts_info file.  We intend to
support DNS fairly comprehensively with this software, but it is not
yet ready for release.

2) Scalability issues

Right now, the Ganymede server loads all data managed into memory.
This is reasonably efficient with a good generational garbage
collector, but it's possible that using a random access binary file
for the database, when combined with an in-memory cache system using
the JDK 1.2 weak references API could give better scalability.  Memory
is cheap these days, so the Ganymede design isn't too bad for our
purposes and size, but it might be good to experiment with the basic
engine to see whether things can be made more scalable with 1.2.

In addition, the client has some scalability issues.  In particular,
there are places where the client will generate pop-up choice lists
with hundreds if not thousands of choices in them.  This is not
workable from a user interface perspective, and may be a real burden
on the client's memory.  For real scalability it might be better to
require the user to manually type in items when the lists get too big.

3) Documentation/Help

The Ganymede client includes support for a basic HTML help system, but
we don't have the HTML help web written.  Given our resources and
priorities, it isn't clear that we'll be able to do this ourselves
anytime soon, but it really should be done.

4) Schema kit code

All of the loader code for the included shema kits is pretty
unpleasant.  We recently incorporated GNU regexp into the server, and
the NIS/GASH loader code should probably take advantage of it.

- 18 June 1999 -

Actually, I did try to do the passwd/group/etc. file parsing using
GNU regexp in the loader code, but it was far too slow for bulk
loading.  I may revisit this if gnu.regexp changes much.

5) Internationalization

It would be a really good thing for the client and server to be
internationalized.  After getting the Ganymede announce posted in
Linux Weekly News and seeing all of the hits from Japan, Italy,
Austria, Russia, China, the Netherlands, France, Spain, Portugal,
etc., my fantasy that internationalization was something I could just
sort of pretend I'd never heard of seems to be evaporating.  I don't
think I'll be able to dedicate time to it anytime in the foreseeable
future, but someone is going to have to at some point.

6) Schema Editor improvements

The schema editing code in the server is one of the more fragile
pieces of code in the server.  It is adequate, but has a tendency to
cause problems if people try to delete or incompatibly change fields
in the database that are currently holding data.  There also seems to
be a persistent error someplace that can sometimes make fields appear
out of order despite dragging them into proper position in the schema
editor.

7) Two phase commit for client access

The Ganymede server internally uses a two-phase commit protocol for
handling its transactions, but it does not provide a two-phase
interface for clients that may be coordinating transaction commits for
an external system.  As a result, while Ganymede can be used to master
cross-database transaction commits using the DBEditObject
commitPhase1() and commitPhase2() methods, it doesn't support a client
attempting to verify transactional consistency without performing an
actual commit.

No one has asked about this yet, but at some point I may need to
expand the client API to allow some sort of 'verify ok to commit'
method call which, if it returns a successful result, will guarantee
that a later commit would proceed to completion successfully.  This
will involve a good bit of reworking of the server's internal commit
operations, and there may be issues of deadlock and timeouts to be
considered as well.  At present, transactions lock all portions of the
database involved in the transaction while the commit logic is being
processed, but if there might be an indefinite delay between phases 1
and 2 of an externally-accessible two phase protocol, we have to
either risk unlocking the server and then hoping we can re-lock the
server in a timely fashion later, or risk leaving those portions of
the server locked until such time as a phase 2 order arrives.

I'm not sure how folks handle this problem, generally.

---

Jonathan Abbey, jonabbey@arlut.utexas.edu
