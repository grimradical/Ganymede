Ganymede Developer Release 0.99.5
July 28, 1999
THINGSTODO
---------------------------------------------

1) DNS Support

The biggest point to make about Ganymede right now is that it is as
much a framework for you to build management software with as it is a
finished product.  In particular, while the gasharl, linux, and bsd
schemas are in decent shape, you have to either already be using GASH
or be willing to settle for simple user/group management if you aren't
willing to do some work to develop a schema that is useful for you.

What is really needed is for someone to develop a generic DNS schema
kit that includes a good general parser for DNS files.  The gasharl
schema is designed to support a single comprehensive NIS domain and a
single DNS domain broken into Class-C sized subnets, but it is
designed to work with files generated/maintained by GASH.

Bootstrapping a DNS management system from zone files needs to be
supported, but Ganymede's objects and links model makes this process
of doing this a bit unobvious.  The gasharl schema uses system
information where all the interfaces and system information for
individual systems is grouped together in objects.  For our network,
this information was collated and assembled by hand.  Hopefully
there's a good way of avoiding that work.

Right now the gasharl schema kit is the most fully developed and
tested schema, but the gasharl schema kit does not include a full
and working NIS/DNS build system.

We are currently developing enhanced DNS support through the use of an
XML layer to replace the old gash hosts_info file.  We intend to
support DNS fairly comprehensively with this software, but it is not
yet ready for release.

2) Scalability issues

Right now, the Ganymede server loads all data managed into memory.
This is reasonably efficient with a good generational garbage
collector, but it's possible that using a random access binary file
for the database, when combined with an in-memory cache system using
the JDK 1.2 weak references API could give better scalability.  Memory
is cheap these days, so the Ganymede design isn't too bad for our
purposes and size, but it might be good to experiment with the basic
engine to see whether things can be made more scalable with 1.2.

In addition, the client has some scalability issues.  In particular,
there are places where the client will generate pop-up choice lists
with hundreds if not thousands of choices in them.  This is not
workable from a user interface perspective, and may be a real burden
on the client's memory.  For real scalability it might be better to
require the user to manually type in items when the lists get too big.

3) Documentation/Help

The Ganymede client includes support for a basic HTML help system, but
we don't have the HTML help web written.  Given our resources and
priorities, it isn't clear that we'll be able to do this ourselves
anytime soon, but it really should be done.

4) Schema kit code

All of the loader code for the included shema kits is pretty
unpleasant.  We recently incorporated GNU regexp into the server, and
the NIS/GASH loader code should probably take advantage of it.

- 18 June 1999 -

Actually, I did try to do the passwd/group/etc. file parsing using
GNU regexp in the loader code, but it was far too slow for bulk
loading.  I may revisit this if gnu.regexp changes much.

5) Internationalization

It would be a really good thing for the client and server to be
internationalized.  After getting the Ganymede announce posted in
Linux Weekly News and seeing all of the hits from Japan, Italy,
Austria, Russia, China, the Netherlands, France, Spain, Portugal,
etc., my fantasy that internationalization was something I could just
sort of pretend I'd never heard of seems to be evaporating.  I don't
think I'll be able to dedicate time to it anytime in the foreseeable
future, but someone is going to have to at some point.

6) Schema Editor improvements

The schema editing code in the server is one of the more fragile pieces
of code in the server.  It is adequate, but has a tendency to cause
problems if people try to delete or incompatibly change fields in
the database that are currently holding data.  There also seems
to be a persistent error someplace that can make fields appear
out of order despite dragging them into proper position in the schema
editor.

---

Jonathan Abbey, jonabbey@arlut.utexas.edu