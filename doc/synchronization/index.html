<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../stylesheets/ganymede.css"/>
    <title>Ganymede Synchronization Guide</title>
  </head>

  <body>
    <IMG SRC="../gifs/ganymede_title.gif" HEIGHT=200 WIDTH=560 alt="Ganymede Logo"/>
    <h1>Ganymede Synchronization Guide<br/>Release 2.0 dev - ? ? 2005<br/>$Rev$</h1>
    <hr/>

    <h2>1. Ganymede, Synchronization, and You</h2>

    <p>Ganymede is a synchronization engine.  Leave aside the
    graphical interface, the programmable business rules, the
    transactional database, all of that.  Ganymede is basically about
    copying data around.  Users and automated processes feed changes
    into Ganymede, and Ganymede makes sure that the updated data gets
    properly fed into whatever directory services or databases the
    adopter might wish to support.</p>

    <p>This document is intended to be a comprehensive guide to
    implementing data synchronization from Ganymede to your target
    directory services.  If you're interested in reading about how to
    format data for importing into Ganymede, you should consult the <a
    href="../xml/index.html">Ganymede XML Guide</a>, which covers that
    topic.</p>

    <p>Whether you are importing data into or exporting data out of
    Ganymede, you will need to be sure that your Ganymede server is
    configured with a schema (and programmable object plug-ins)
    appropriate to the sort of data you want to manage.  See the <a
    href="../xml/schema.html">Ganymede XML Schema</a> document for some
    details on how a Ganymede schema is specified.  (I need to add
    more discussion of this somewhere in the docs, though).</p>

    <p>Now, assuming that you have gotten your Ganymede server's
    schema and plug-in logic set up appropriately and that you have
    got data successfully imported, we need to talk about getting that
    data back out again, and transferred to the services you are
    trying to administer.</p>

    <h2>2. Approaches to Synchronization</h2>

    <p>Ganymede is designed around a transactional model, in which a
    set of changes that transition the Ganymede server from one
    consistent state to another are processed as a single unit of
    work.  As such, the transaction is both the minimum unit of change
    for Ganymede and the trigger that causes the Ganymede server to
    synchronize its data to target directory services.</p>

    <p>There are, in priniciple, two ways that Ganymede might handle
    synchronizing data to the services that it feeds.  It could dump
    out everything it knows and arrange for that 'full state'
    information to completely replace the previous state of the
    external managed services, or it could just send out information
    about the transactions that were made since the last
    synchronization.  Directory services like NIS and DNS have
    traditionally required a 'full state' build system, as those
    services originally provided no mechanism for applying incremental
    changes to their configuration.  Modern directory services like
    LDAP, on the other hand, explicitly support incremental change
    commands.  These kinds of directories work most efficiently when a
    small list of recent changes (or "deltas") can be provided.  Other
    possible synchronization targets, such as relational databases,
    may be handled in either manner.</p>

    <p>These two synchronization styles each have their own strengths
    and weaknesses.  With a full state synchronization, it really
    doesn't matter whether any previous synchronizations were
    successful or not, because each synchronization will contain a
    complete description of the desired configuration for the target
    service.  This means that missing a synchronization because the
    target directory service is temporarily unavailable is no problem.
    The target directory will just catch up the next time a
    synchronization occurs.  The inherent redundancy of this approach
    can make the synchronization process very robust, but the downside
    is that a full state synchronization can be very time consuming.
    The synchronization process must involve writing out all known
    data each time any changes are made.  In addition, if it isn't
    possible to efficiently wipe and reload the target directory
    service, a process of comparison must be undertaken to calculate
    what has changed between the data written out for the
    synchronization requires and the pre-existing configuration of the
    target directory service.  In some cases, including that of
    passwords in Active Directory, it may not even be possible to
    completely read the pre-existing data from the target directory
    service in order to be able to detect what has changed.  This may
    mean that more data will need to be sent to the target service
    than is strictly necessary, even if that same data is already
    securely (but unretrievably) held in the target service.</p>

    <p>Synchronizing only the recently applied transactions can be far
    more efficient, assuming the target directory service can accept
    and apply a set of changes.  Only a very small amount of data
    needs to be synchronized at each synchronization, and the target
    directory service doesn't need to erase or reload anything other
    than what actually changed.  This kind of "delta" synchronization,
    however, has some severe shortcomings.  The first problem is that
    if we are only sending the most recent transactions, we have to
    absolutely rely on the target directory service to remember all
    previous changes.  If a transaction were to get lost somehow, the
    target directory service would become out of sync with the master
    data held in Ganymede, and later synchronizations might never
    detect or fix the problem.  Another problem is that if we limit
    the amount of data we send to the synchronization channel to only
    that which recently changed, we might fail to provide enough
    surrounding context to allow the synchronization system to
    translate the synchronziation data into a form suitable to the
    target directory service.  It wouldn't do, for example, to try and
    write to a synchronization channel the fact that a user's password
    changed without also including enough surrounding context to allow
    the synchronization system to locate the user record to
    be changed in the target service.</p>

    <p>As it happens, Ganymede 2.0 provides three distinct systems for
    data synchronization.  Two are based on the full state
    synchronization model and one on the transactional delta model.
    The two full state models differ mostly in where the logic for the
    synchronization process is placed, and in when and how the
    synchronizations are triggered.  We'll start first by talking
    about the original Ganymede 1.0 full state synchronization model,
    before considering the two new models that Ganymede 2.0
    introduces.</p>

    <h2 id="buildertask">3. The GanymedeBuilderTask Synchronization Model</h2>

    <h3 id="buildertask_explained">The GanymedeBuilderTask Model Explained</h3>

    <p>The original Ganymede synchronization model is based around
    full state synchronization, and was designed in conjunction with
    the Ganymede transactional model to support NIS and DNS.  Both of
    those directory services require all related changes to be made
    all at once before rebuilding their state ("pushing the maps" in
    NIS terminology, "rebuilding the BIND zone files" in DNS terms).</p>

    <p>Ganymede's approach to supporting these services is to
    implement a two phase building approach, using the <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">arlut.csd.ganymede.server.GanymedeBuilderTask</a>
    class.  When a transaction is committed in Ganymede, the <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeScheduler.html">
    arlut.csd.ganymede.server.GanymedeScheduler</a> class schedules a
    set of builder tasks for execution as soon as possible.  When a
    builder task runs, it locks the Ganymede database to prevent any
    new transactions from committing and it executes <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase1()">builderPhase1</a>.
    The builderPhase1 method scans the Ganymede database for whatever
    objects are relevant to the builder task's synchronization duties
    and writes that data out to disk, using whatever data format is
    convenient for the purposes of that synchronization channel.  When
    the builder task completes its scan of the Ganymede database and
    writes out all its data, the builderPhase1() method returns, and
    the Ganymede database is unlocked so that any pending transactions
    can commit.</p>

    <p>The builder tasks then runs <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase2()">builderPhase2</a>.
    builderPhase2 is designed to execute an external program or script
    which reads the data written out by builderPhase1 and does
    whatever is necessary to integrate that data into the target
    directory services.  During the time that builderPhase2 is
    running, users are free to commit changes into the Ganymede
    database, but the Ganymede Scheduler is blocked from re-running the
    same builder task again.  This prevents any possibility of the
    builder task synchronization overlapping itself and overwriting
    data that a previous external build process may still be working
    with.</p>

    <p>Because the Ganymede Scheduler waits until a builder task has
    completed running before it relaunches the task, transactions are
    effectively transmitted in bulk to the target service.  If it
    takes 5 minutes for the external script run by builderPhase2() to
    complete, potentially hundreds or thousands of changes can be
    'saved up' for the builder task to handle when it finishes with
    the first synchronization.  In this way, the Ganymede server can
    allow users to commit changes at the fastest rate possible, while
    simultaneously synchronizing data to the target services at the
    fastest rate the synchronization process will allow.</p>

    <p>There are two difficulties with this synchronization model.
    The first is that by the time a builder task is executed by the
    Ganymede Scheduler, several minutes might have passed, during which
    time the Ganymede server will have completely forgotten about what
    the Ganymede server's data looked like before the transactions
    were committed.  Because of this, the GanymedeBuilderTask model is
    completely incapable of doing delta-style builds.  The best that
    it can do is to write out everything it knows to be true at the
    time the builderPhase1() method is run, and to depend on the
    external build process run by builderPhase2() to do a
    before-and-after comparison between the previous synchronization
    and the current one.  This is completely dependent on the external
    build process having enough logic to save away the earlier
    synchronization's data and carry out the comparison.</p>

    <p>The second difficulty with the GanymedeBuilderTask model is
    that it depends on a lot of custom code being written in Java and
    compiled into the Ganymede server.  In order to create a custom
    GanymedeBuilderTask, the adopter must create his own subclass of
    GanymedeBuilderTask and write all the logic for builderPhase1 and
    builderPhase2.  Further, if the code in either of these methods
    need to change, either to fix a bug or to respond to a change made
    in the Ganymede server's schema, the server would have to be
    stopped and restarted after compiling and loading the new version
    of the builder task's code.</p>

    <p>The advantage of using the GanymedeBuilderTask system is that
    it is the only full state synchronization model that is fully
    integrated into the Ganymede server's scheduler.  By creating and
    registering a GanymedeBuilderTask, you can rely on the server to
    handle scheduling your builds.  The alternative XML-based full
    state synchronization model (<a href="xml_full_state">described
    below</a>) is meant only to serve as a manual backup for the
    Ganymede 2.0 XML-based delta synchronization model.</p>

    <p>Right now, we need to discuss how to actually go about
    constructing a GanymedeBuilderTask subclass to handle a full state
    build.</p>

    <h3 id="buildertask_creation">How To Create A Custom GanymedeBuilderTask Subclass</h3>

    <p>The <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">GanymedeBuilderTask</a>
    class is responsible for coordinating all of the activities
    involved in scheduling and executing full state builds.  As an
    adopter and customizer of Ganymede, all you are responsible for is
    creating a subclass of <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">GanymedeBuilderTask</a>
    that defines the <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase1()">builderPhase1()</a>
    and <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase2()">builderPhase2()</a>
    methods.</p>

    <p>The steps involved in creating a <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">GanymedeBuilderTask</a>
    subclass and linking it into the server are very similar to those
    involved in <a
    href="../customization/index.html#subclass_creation">creating a
    DBEditObject subclass</a>.  You have to create a <code
    class="filename">.java</code> file that contains your subclass and
    place it under the server's <code
    class="filename">schema/custom_src</code> directory.  You then
    compile your code with the <code class="filename">build</code>
    script.  After you are sure that your code compiles successfully,
    you must shut down the server and rebuild the <code
    class="filename">custom.jar</code> file with the <code
    class="filename">buildCustomJar</code> script.  You can then start
    up your server and your new <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">GanymedeBuilderTask</a>
    subclass should be accessible to the Ganymede server.  Accessible,
    but not yet linked into the Ganymede database for actual use.</p>

    <h4 id="creating_buildertask">Registering Your Builder Task For Execution</h4>

    <p>Once you have updated your server's <code
    class="filename">custom.jar</code> file with your new builder
    task, you have to register your new builder task with the server.
    You do this by creating a new <code class="type">Task</code>
    object in the Ganymede server.  The <code class="type">Task</code>
    Object type is fully described in the <a
    href="../server.html#servertasks">Ganymede Server
    Overview</a>.</p>

    <p>For a builder task, there are four fields you need to worry
    about: <code class="type">Task Name</code>, <code
    class="type">Task Class</code>, <code class="type">Run On
    Transaction Commit</code>, and <code class="type">Option
    Strings</code>.  The <code class="type">Task Name</code> field
    controls the name of the Task as seen in the admin console's task
    monitor display, and must be unique in the Ganymede server.  The
    <code class="type">Task Class</code> field should contain the
    fully qualified class name for your custom <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">GanymedeBuilderTask</a>
    subclass.  The <code class="type">Run On Transaction Commit</code>
    checkbox should be checked to indicate that this task is to be
    scheduled for execution as soon as possible after each transaction
    is committed, and the <code class="type">Option Strings</code>
    field is used to provide optional run-time configuration
    information to builder tasks that are programmed to look for
    it.</p>

    <p>Below is an example of a builder task that has been
    registered in the Ganymede server.  It is configured to be
    scheduled for execution after transactions are committed, and it
    has a name and a class.</p>

    <center><img src="screenshots/builder_task.png" class="screenshot"/></center>

    <p>As soon as the admin hits the <code type="button">Commit</code>
    button at the bottom right, the task will be registered in the
    server.  From this commit on, the task will be scheduled for
    execution whenever a transaction is committed.</p>

    <p>Now, not every transaction or sequence of transactions
    committed will necessarily be of interest to any given builder
    task.  To help you deal with this, <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">GanymedeBuilderTask</a>
    provides a method called <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#baseChanged(short)">baseChanged()</a>,
    which allows you to test to see whether any changes have been made
    to a given object type since the last time your builder task was
    run.  You'll see how this works in our example builder task in the
    next section.</p>
    
    <h3 id="buildertask_whaaaa">What A Builder Task Looks Like</h3>

    <p>What follows is the complete UNIXBuilderTask class from the
    Ganymede userKit.  It will illustrate a lot of the principles of
    writing a full-state builder task with the GanymedeBuilderTask
    class.</p>

    <samp class="listing">
package arlut.csd.ganymede.userKit;

import arlut.csd.ganymede.server.*;
import arlut.csd.ganymede.common.*;
import arlut.csd.Util.FileOps;

import java.util.*;
import java.text.*;
import java.io.*;

</samp>
<p>First we have our beginning declarations.  Generally speaking,
you'll create a separate package for your custom schema classes, and
you'll need to import everything from the
<code>arlut.csd.ganymede.server</code> and
<code>arlut.csd.ganymede.common</code> packages.</p>
<samp class="listing">

/**
 * This class is intended to dump the Ganymede datastore to the
 * UNIX passwd and group files.
 */

public class UNIXBuilderTask extends GanymedeBuilderTask {

  private String buildScript = null;
  private String md5passwdFile =  null;
  private String passwdFile = null;
  private String groupFile = null;

  // ---

  private Date now = null;
  private boolean backedup = false;

  /* -- */

  /**
   * &lt;p&gt;The constructor for GanymedeBuilderTask subclasses takes an
   * Invid for the DBObject in the Ganymede data store that defines
   * the task.  The taskDefObjInvid member variable is comes from the
   * GanymedeBuilderTask that we are inheriting from.  Setting it
   * in this constructor allows us to use the getOptionValue() method to read
   * our configuration strings for this task.&lt;/p&gt;
   */

  public UNIXBuilderTask(Invid _taskObjInvid)
  {
    // set the taskDefObjInvid in GanymedeBuilderTask so
    // we can look up option strings

    taskDefObjInvid = _taskObjInvid;
  }

</samp>
<p>And here we see the class declaration subclassing
GanymedeBuilderTask, member variable declarations, and our
constructor, which must take an <a
href="../javadoc/arlut/csd/ganymede/common/Invid.html">Invid</a>
parameter, and set the <a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#taskDefObjInvid">taskDefObjInvid</a>
variable from the GanymedeBuilderTask class.</p>
<samp class="listing">

  /**
   * This method runs with a dumpLock obtained for the builder task.
   *
   * Code run in builderPhase1() can call enumerateObjects() and
   * baseChanged().
   *
   * @return true if builderPhase1 made changes necessitating the
   * execution of builderPhase2.
   */

  public boolean builderPhase1()
  {
    PrintWriter out;
    boolean result = false;

    /* -- */

    // initialize operational variables for the new run

    backedup = false;
    now = null;

    // now see what our current option values are

    passwdFile = getOptionValue("passwdFile");
    md5passwdFile = getOptionValue("md5passwdFile");

    if (passwdFile == null && md5passwdFile == null)
      {
	Ganymede.debug("UNIXBuilderTask: error, no passwdFile specified");
      }

    if (passwdFile != null && passwdFile.equals(md5passwdFile))
      {
	Ganymede.debug("UNIXBuilderTask: error, md5passwdFile and passwdFile are the same, skipping md5passwdFile");
	md5passwdFile = null;
      }

    groupFile = getOptionValue("groupFile");

    if (groupFile == null)
      {
	Ganymede.debug("UNIXBuilderTask: error, no groupFile specified");
      }

    // passwd

    if (baseChanged(SchemaConstants.UserBase))
      {
	Ganymede.debug("UNIXBuilderTask: Need to build user map");

	if (passwdFile != null) 
	  {
	    out = null;

	    try
	      {
		out = openOutFile(passwdFile, "unix");
	      }
	    catch (IOException ex)
	      {
		ex.printStackTrace();
		Ganymede.debug("UNIXBuilderTask.builderPhase1(): couldn't open " + passwdFile + ": " + ex);
	      }
	  
	    if (out != null)
	      {
		Enumeration users = enumerateObjects(SchemaConstants.UserBase);
	      
		while (users.hasMoreElements())
		  {
		    DBObject user = (DBObject) users.nextElement();
		  
		    writeUserLine(user, out, false);
		  }
	      
		out.close();
	      }

	    result = true;
	  }

	if (md5passwdFile != null) 
	  {
	    out = null;

	    try
	      {
		out = openOutFile(md5passwdFile, "unix");
	      }
	    catch (IOException ex)
	      {
		ex.printStackTrace();
		Ganymede.debug("UNIXBuilderTask.builderPhase1(): couldn't open " + md5passwdFile + ": " + ex);
	      }
	  
	    if (out != null)
	      {
		Enumeration users = enumerateObjects(SchemaConstants.UserBase);
	      
		while (users.hasMoreElements())
		  {
		    DBObject user = (DBObject) users.nextElement();
		  
		    writeUserLine(user, out, true);
		  }
	      
		out.close();
	      }

	    result = true;
	  }
      }

    // group

    if (baseChanged((short) 257))
      {
	Ganymede.debug("UNIXBuilderTask: Need to build group map");

	if (groupFile != null)
	  {
	    out = null;

	    try
	      {
		out = openOutFile(groupFile, "unix");
	      }
	    catch (IOException ex)
	      {
		ex.printStackTrace();
		Ganymede.debug("UNIXBuilderTask.builderPhase1(): couldn't open " + groupFile + ": " + ex);
	      }
	
	    if (out != null)
	      {
		Enumeration groups = enumerateObjects((short) 257);

		while (groups.hasMoreElements())
		  {
		    DBObject group = (DBObject) groups.nextElement();

		    writeGroupLine(group, out);
		  }

		out.close();
	      }

	    result = true;
	  }
      }

    return result;
  }
</samp>

<p>And here we have our <a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase1()">builderPhase1()</a>
method.  The important things to note here are the use of the <a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#getOptionValue(java.lang.String)">getOptionValue()</a>
method to look for option strings from our Task object, the use of the
<a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#baseChanged(short)">baseChanged()</a>
method to determine whether any objects of a given type have changed
since this builder task was last run, the use of the <a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#openOutFile(java.lang.String,
java.lang.String)">openOutFile()</a> method for opening files for
writing, and the use of the <a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#enumerateObjects(short)">enumerateObjects()</a>
method for iterating over objects of a given type.  Each of these
methods take advantage of logic built in to the GanymedeBuilderTask
class, and will help your builder task code behave properly.</p>

<p>As you may notice above, baseChanged() and enumerateObjects() both
take a numeric parameter (a short) to describe what object type the method is to operate on.</p>

<p>The overall effect of builderPhase1() is to look to see whether any
users or groups, as defined in the userKit schema, have changed since
this builder task was last run, and if so, to write out passwd and
group files suitable for integration into a simple NIS or <code
class="filename">/etc/passwd</code>, <code
class="filename">/etc/group</code> type environment.</p>

<p>If no users or groups have changed, this builderPhase1() method
will return false, which will tell the GanymedeBuilderTask base class
not to bother running builderPhase2().</p>

<samp class="listing">

  /**
   *
   * This method runs after this task's dumpLock has been
   * relinquished.  This method is intended to be used to finish off a
   * build process by running (probably external) code that does not
   * require direct access to the database.
   *
   * builderPhase2 is only run if builderPhase1 returns true.
   *
   */

  public boolean builderPhase2()
  {
    File
      file;

    /* -- */

    buildScript = getOptionValue("buildScript");

    if (buildScript == null || buildScript.equals(""))
      {
	Ganymede.debug("UNIXBuilderTask: no buildScript defined in task object's option string vector");
	Ganymede.debug("                 not running any external update script.");
	return false;
      }

    file = new File(buildScript);

    if (file.exists())
      {
	Ganymede.debug("UNIXBuilderTask builderPhase2 running");

	try
	  {
	    FileOps.runProcess(buildScript);
	  }
	catch (IOException ex)
	  {
	    Ganymede.debug("Couldn't exec buildScript (" + buildScript + ") due to IOException: " + ex);
	  }
	catch (InterruptedException ex)
	  {
	    Ganymede.debug("Failure during exec of buildScript (" + buildScript + "): " + ex);
	  }
      }
    else
      {
	Ganymede.debug(buildScript + " doesn't exist, not running external UNIX build script");
      }

    Ganymede.debug("UNIXBuilderTask builderPhase2 completed");

    return true;
  }
</samp>

<p><a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase2()">builderPhase2()</a>,
by contrast, is much simpler.  It uses the <a
href="../javadoc/arlut/csd/Util/FileOps.html#runProcess(java.lang.String)">runProcess()</a>
method to try to run a builder script that is designated in the Task
object's <code class="type">Option Strings</code> field.  Finding and
running the external script is all that builderPhase2() is responsible
for.  The external builder script is responsible for making sure that
everything is set up for it to run.  The Ganymede server makes no
guarantees as to the working directory the script will be run in, and
no guarantees about what any environment variables will be set to.  If
your external builder script needs to worry about things like that,
you should make sure that your external builder script sets all that
up for itself.</p>

<p>The other thing you need to know when writing your external builder
script is that it should block until it finishes with its build.  The
Ganymede Scheduler creates an independent thread for each builder task
that runs, and it is expected that that thread will block until your
external builder task has completely finished its work.  If your
external builder script were to put itself into the background and
return early, the Ganymede Scheduler would consider the builder task
completely finished, and it would feel free to run the task all over
again, which might cause your builderPhase1() method to overwrite
files that your external builder script is still working with.</p>

<p>What I say to you three times is true.  Never let your external
builder script return until it is truly finished with its build.</p>

<samp class="listing">

  // ***
  //
  // The following private methods are used to support the UNIX builder logic.
  //
  // ***

  /**
   *
   * This method writes out a line to the passwd UNIX source file.
   *
   * The lines in this file look like the following.
   *
   * broccol:393T6k3e/9/w2:12003:12010:Jonathan Abbey,S321 CSD,3199,8343915:/home/broccol:/bin/tcsh
   *
   * @param object An object from the Ganymede user object base
   * @param writer The destination for this user line
   * @param useMD5 If true, passwords will be written out in md5 format if possible
   *
   */

  private void writeUserLine(DBObject object, PrintWriter writer, boolean useMD5)
  {
    String username;
    String cryptedPass = null;
    int uid;
    int gid;
    String name;
    String room;
    String officePhone;
    String homePhone;
    String directory;
    String shell;

    PasswordDBField passField;
    Vector invids;
    Invid groupInvid;
    DBObject group;

    StringBuffer result = new StringBuffer();

    /* -- */

    username = (String) object.getFieldValueLocal(SchemaConstants.UserUserName);

    passField = (PasswordDBField) object.getField(SchemaConstants.UserPassword);

    if (passField != null)
      {
	if (useMD5)
	  {
	    cryptedPass = passField.getMD5CryptText();
	  }

	// if the Ganymede server doesn't have an MD5 password for
	// this user, go ahead and devolve to the crypt() password if
	// available.  This might have been set by rpcpass and the NIS
	// passwd daemon.

	if (cryptedPass == null)
	  {
	    cryptedPass = passField.getUNIXCryptText();
	  }
      }
    else
      {
	Ganymede.debug("UNIXBuilderTask.writeUserLine(): null password for user " + username);
	cryptedPass = "**Nopass**";
      }

    uid = ((Integer) object.getFieldValueLocal(userSchema.UID)).intValue();

    // get the gid
    
    groupInvid = (Invid) object.getFieldValueLocal(userSchema.HOMEGROUP); // home group

    if (groupInvid == null)
      {
	Ganymede.debug("UNIXBuilderTask.writeUserLine(): null gid for user " + username);
	gid = -1;
      }
    else
      {
	group = getObject(groupInvid);

	if (group == null)
	  {
	    Ganymede.debug("UNIXBuilderTask.writeUserLine(): couldn't get reference to home group");

	    gid = -1;
	  }
	else
	  {
	    Integer gidInt = (Integer) group.getFieldValueLocal(groupSchema.GID);

	    if (gidInt == null)
	      {
		Ganymede.debug("UNIXBuilderTask.writeUserLine(): couldn't get gid value");

		gid = -1;
	      }
	    else
	      {
		gid = gidInt.intValue();
	      }
	  }
      }

    name = (String) object.getFieldValueLocal(userSchema.FULLNAME);
    room = (String) object.getFieldValueLocal(userSchema.ROOM);
    officePhone = (String) object.getFieldValueLocal(userSchema.OFFICEPHONE);
    homePhone = (String) object.getFieldValueLocal(userSchema.HOMEPHONE);
    directory = (String) object.getFieldValueLocal(userSchema.HOMEDIR);
    shell = (String) object.getFieldValueLocal(userSchema.LOGINSHELL);

    // now build our output line

    result.append(username);
    result.append(":");
    result.append(cryptedPass);
    result.append(":");
    result.append(Integer.toString(uid));
    result.append(":");
    result.append(Integer.toString(gid));
    result.append(":");

    result.append(name);

    if (room != null && !room.equals(""))
      {
	result.append(",");
	result.append(room);
      }

    if (officePhone != null && !officePhone.equals(""))
      {
	result.append(",");
	result.append(officePhone);
      }

    if (homePhone != null && !homePhone.equals(""))
      {
	result.append(",");
	result.append(homePhone);
      }

    result.append(":");
    result.append(directory);
    result.append(":");
    result.append(shell);

    if (result.length() > 1024)
      {
	Ganymede.debug("UNIXBuilderTask.writeUserLine(): Warning!  user " + 
		       username + " overflows the UNIX line length!");
      }

    writer.println(result.toString());
  }

  /**
   *
   * This method writes out a line to the group UNIX source file.
   *
   * The lines in this file look like the following.
   *
   * adgacc:ZzZz:4015:hammp,jgeorge,dd,doodle,dhoss,corbett,monk
   *
   * @param object An object from the Ganymede user object base
   * @param writer The destination for this user line
   *
   */

  private void writeGroupLine(DBObject object, PrintWriter writer)
  {
    String groupname;
    String pass;
    int gid;
    Vector users = new Vector();

    PasswordDBField passField;
    Vector invids;
    Invid userInvid;
    String userName;

    StringBuffer result = new StringBuffer();

    /* -- */

    groupname = (String) object.getFieldValueLocal(groupSchema.GROUPNAME);

    // currently in the Ganymede schema, group passwords aren't in passfields.

    pass = (String) object.getFieldValueLocal(groupSchema.PASSWORD);

    Integer gidInt = (Integer) object.getFieldValueLocal(groupSchema.GID);

    if (gidInt == null)
      {
	Ganymede.debug("Error, couldn't find gid for group " + groupname);
	return;
      }

    gid = gidInt.intValue();
    
    // we currently don't explicitly record the home group.. just take the first group
    // that the user is in.

    invids = object.getFieldValuesLocal(groupSchema.USERS);

    if (invids == null)
      {
	// Ganymede.debug("UNIXBuilder.writeUserLine(): null user list for group " + groupname);
      }
    else
      {
	for (int i = 0; i < invids.size(); i++)
	  {
	    userInvid = (Invid) invids.elementAt(i);
	    
	    userName = getLabel(userInvid);

	    if (userName != null)
	      {
		users.addElement(userName);
	      }
	  }
      }

    // now build our output line

    result.append(groupname);
    result.append(":");
    result.append(pass);
    result.append(":");
    result.append(Integer.toString(gid));
    result.append(":");

    for (int i = 0; i < users.size(); i++)
      {
	if (i > 0)
	  {
	    result.append(",");
	  }

	result.append((String) users.elementAt(i));
      }

    if (result.length() > 1024)
      {
	Ganymede.debug("UNIXBuilderTask.writeGroupLine(): Warning!  group " + 
		       groupname + " overflows the UNIX line length!");
      }

    writer.println(result.toString());
  }
}
</samp>

<p>All of the rest of the class is dedicated to utility helper methods
that are used to handle chores for the <a
href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase1()">builderPhase1()</a>
method.  One of the things you will notice about these methods is
that they have been written to use the Ganymede <a
href="../javadoc/arlut/csd/ganymede/server/DBObject.html">DBObject</a>
class API to access data from objects in the Ganymede data store.  You
will also notice that the calls to <a
href="../javadoc/arlut/csd/ganymede/server/DBObject.html#getFieldValueLocal(short)">getFieldValueLocal()</a>
are using numeric identifiers, in this case defined in the <code
class="type">userSchema</code> and <code
class="type">groupSchema</code> interfaces, to retrieve specific
fields.</p>

<p>In general, whenever you use the GanymedeBuilderTask model for
handling synchronization, you will have to write Java code that uses
low-level details of the internal Ganymede API and that is aware of
the specific structure and details of your schema.  You're quite
correct if you consider the necessity of coding at this level to be a
disadvantage of using the GanymedeBuilderTask approach.</p>

    <h2 id="xml_incrementals">4. The Sync Channel Synchronization Model</h2>

    <p>Ganymede 2.0 introduces an incremental XML-based
    synchronization system, which we call the "Sync Channel
    Synchronization Model".  The Sync Channel model shares enough
    similarities to the GanymedeBuilderTask model that you will
    recognize some familiar concepts, but the differences are
    significant.</p>

    <p>The general structure and timing of the Sync Channel system is
    both similar to and different from the GanymedeBuilderTask model.
    As with GanymedeBuilderTask, synchronization is a two-step
    process.  In the first step, the Ganymede server writes out files
    with synchronization information.  In the second step, an external
    process is initiated to incorporate that synchronization data into
    targeted services.  In the GanymedeBuilderTask model, both of
    these steps are scheduled to occur as soon as possible after a
    transaction is committed, and the second step follows immediately
    after the first.</p>

    <p>In the Sync Channel model, the first step of writing out the
    synchronization data is always done synchronously with the
    transaction commit process.  (So much so, in fact, that a
    transaction is not considered committed until all registered Sync
    Channels have finished writing out their synchronization files.)
    The second step is scheduled for asynchronous execution with the
    Ganymede Scheduler as soon as possible after a transaction is
    committed.  This usually means that the external synchronization
    will occur immediately, but if the Sync Channel is still executing
    a previous external synchronization, the external process for step
    two will not run until the previous run finishes.</p>

    <p>Because synchronization data may be written out with every
    transaction that is committed while the external processing step
    may execute after some delay, synchronization data can accumulate
    as it waits to be processed.  The Sync Channel Synchronization
    Model must therefore act as a message queueing system.  The
    message queue represents the 'channel' that gives the Sync Channel
    Synchronization Model its name.</p>

    <p>The Sync Channel Synchronization Model is designed to require
    less customization of the Ganymede server.  Where the
    GanymedeBuilderTask model requires adopters to write their own <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase1()">builderPhase1()</a>
    methods in order to write out custom data files, the Sync Channel
    system uses a standard XML format which is generated by standard
    logic in the <a
    href="../javadoc/arlut/csd/ganymede/server/SyncRunner.html">SyncRunner</a>
    class.  The external synchronization process must be smart enough
    to interpret the XML synchronization data, but it generally works
    out better to have this logic be outside of the Ganymede server,
    where it can more easily be maintained.</p>

    <center><img src="screenshots/sync_channel.png" class="screenshot"/></center>

    <hr/>
    <address><a href="mailto:jonabbey@arlut.utexas.edu">Jonathan Abbey</a></address>
    <p class="address">$Date$, $Rev$, $Author$</p>
  </body>

</html>
