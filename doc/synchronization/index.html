<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../stylesheets/ganymede.css"/>
    <title>Ganymede Synchronization Guide</title>
  </head>

  <body>
    <!--<IMG SRC="../gifs/ganymede_title.gif" HEIGHT=200 WIDTH=560 alt="Ganymede Logo"/>
    <h1>Ganymede Synchronization Guide<br/>Release 2.0 dev - ? ? 2005<br/>$Rev$</h1>
    <hr/>-->

    <div id="header">
      <IMG SRC="../gifs/ganymede_title.gif" alt="Ganymede Logo"/>

      <div id="title">
        <h1>Ganymede 2.0 Sync Channel Guide</h1>
        <p>Release 2.0 dev - ? ? 2005<br/>$Rev$</p>
      </div>

      <div id="abstract">
        <p>This document is intended to be a comprehensive guide to
        implementing data synchronization from Ganymede to your target
        directory services, using the new Ganymede 2.0 Sync Channel
        mechanism.  This guide covers neither importing data
        <b>into</b> Ganymede (see the <a
        href="../xml/index.html">Ganymede XML Guide</a> for that), nor
        the use of the older and more tricky Ganymede 1.0
        synchronization system.  For the latter, consult the <a
        href="ganymedebuildertask.html">GanymedeBuilderTask
        Synchronization Guide</a>.</p>

        <p>This guide likewise assumes that you already know enough
        about the Ganymede data model to configure a Ganymede schema
        that is capable of containing and modeling the directory
        services data that you want to manage with Ganymede.  If this
        is not the case, you might want to read the <a
        href="../xml/schema.html">Ganymede XML Schema</a> document for
        some details on how a Ganymede schema is specified.</p>

        <p class="note">A more general Ganymede data model / schema
        document still needs to be put together at the time of this
        writing (11 April 2005).</p>
      </div>

      <p>By <a href="mailto:jonabbey@arlut.utexas.edu">Jonathan Abbey</a></p>
    </div>

    <h2>1. Approaches to Synchronization</h2>

    <p>Ganymede is designed around a transactional model, in which a
    set of changes that transition the Ganymede server from one
    consistent state to another is processed as a single unit of work.
    As such, the transaction is both the minimum unit of change for
    Ganymede and the trigger that causes the Ganymede server to
    synchronize its data to target directory services.</p>

    <p>Given this, there are in principle two ways that Ganymede might
    handle synchronizing data to the services that it feeds:</p>

    <ol>
      <li>Dump out everything it knows relevant to the
      synchronization and arrange for that 'full state' information
      to completely replace the previous state of the external
      managed services.</li>

      <li>Just send out relevant information that has changed since
      the last synchronization.</li>
    </ol>

    <p>Directory services like NIS and DNS have traditionally required
    a 'full state' build system, as those services originally provided
    no mechanism for applying incremental changes to their
    configuration.  Modern directory services like LDAP, on the other
    hand, explicitly support incremental change commands.  Applying
    changes to these kinds of directories works most efficiently when
    a small list of recent changes ("deltas") can be provided.</p>

    <p>These two synchronization styles each have their own strengths
    and weaknesses.</p>

    <h3 id="describing_full_state">Full State Synchronization</h3>

    <p>With a full state synchronization, it really doesn't matter
    whether any previous synchronizations were successful or not,
    because each synchronization will contain a complete description
    of the desired configuration for the target service.  This means
    that missing a synchronization (perhaps because the target
    directory service is temporarily unavailable) is no problem.  The
    target directory will just catch up the next time a
    synchronization occurs.  The inherent redundancy of this approach
    can make the synchronization process very robust, but the downside
    is that a full state synchronization can be very time
    consuming.</p>

    <p>In addition, if it isn't possible to efficiently wipe and
    reload the target directory service, a process of comparison must
    be undertaken to calculate what has changed between the data
    written out for the synchronization requires and the pre-existing
    configuration of the target directory service.  In some cases it
    may not even be possible to read the pre-existing data from the
    target directory service in order to be able to detect what has
    changed.  This is the case of <code class="type">ntPassword</code>
    in Active Directory, for instance, which is a write-only field.
    Without being able properly to compare the full state data with
    the contents of the target service may mean that more changes will
    have to be sent to the target than would be necessary with a true
    incremental synchronization.</p>

    <h3 id="describing_incremental">Incremental Synchronization</h3>

    <p>Synchronizing only the recently applied transactions can be far
    more efficient, assuming the target directory service can accept
    and apply a set of changes.  Only a very small amount of data may
    need to be synchronized at each synchronization, and it's not
    necessary for the target directory service to erase or reload
    anything other than what actually changed.</p>

    <p>This kind of "delta" synchronization, however, has some severe
    shortcomings.  The first problem is that if we are only sending
    the most recent transactions, we must absolutely rely on the
    target directory service to remember all previous changes.  If a
    transaction were to get lost somehow, the target directory service
    would become out of sync with the master data held in Ganymede,
    and later synchronizations might never detect or fix the problem.</p>

    <p>Another problem is that if we limit the amount of data we send
    to the synchronization channel to only that which recently
    changed, we might fail to provide enough surrounding context to
    allow the synchronization system to translate the synchronization
    data into a form suitable to the target directory service.  It
    wouldn't do, for example, to try and write to a synchronization
    channel the fact that a user's password changed without also
    including enough surrounding context to allow the synchronization
    system to locate the user record to be changed in the target
    service.</p>

    <h2 id="options">2. Ganymede Synchronization</h2>

    <p>Ganymede synchronization is organized around a two step
    process.  In the first step, the Ganymede server writes out
    synchronization data, typically to files on your server system's
    disk. In the second step, an external, free-standing program is
    then run to read in these data files and do whatever may be
    required to transmit the synchronization information to target
    services.  This division of labor between the Ganymede server and
    your external code allows for a great degree of flexibility,
    without requiring extensive code development within the Ganymede
    server itself.</p>

    <p>Originally, the implementing the first step of this process
    required subclassing the <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">arlut.csd.ganymede.server.GanymedeBuilderTask</a>
    class in the Ganymede server and writing custom Java code to scan
    the portions of the Ganymede data store relevant to a specific
    synchronization task and to write out custom-formatted data files.
    This approach required the adopter to get intimately familiar with
    the complex internal Ganymede <a
    href="../javadoc/arlut/csd/ganymede/server/DBStore.html">DBStore</a>
    APIs for examining data in the Ganymede server.  Not an easy thing
    to do (or to document), and the necessity of recompiling Java code
    and stopping and restarting the Ganymede server made things more
    difficult.</p>

    <p>We still support (and ourselves rely on) the
    GanymedeBuilderTask synchronization infrastructure, but we don't
    want to emphasize its use for new adopters of Ganymede.  If you're
    interested in reading about the advantages of the older sync
    model, please consult the <a
    href="ganymedebuildertask.html">GanymedeBuilderTask
    Synchronization Guide</a> for details.</p>

    <p>With Ganymede 2.0, we introduce a new synchronization
    infrastructure built around a new Ganymede construct, the <code
    class="type">Sync Channel</code>.  Sync Channel synchronization
    takes advantage of code that we've built into the Ganymede server
    for you that uses an XML file format for writing out both
    incremental and full state synchronization data.</p>

    <p>You can configure <code class="type">Sync Channels</code>
    through the Ganymede GUI client and/or the Ganymede <a
    href="../xml/xmlclient.html">xmlclient</a>, and you can redefine
    them whenever you like.

    <h2 id="xml_incrementals">5 Incremental Sync Channels</h2>

    <h3 id="explaining_xml_incrementals">The Sync Channel Incremental Model Explained</h3>

    <p>Ganymede 2.0 introduces an incremental XML-based
    synchronization system, which we call the "Sync Channel
    Incremental Model".  The Sync Channel Incremental model shares
    enough similarities to the GanymedeBuilderTask model that you will
    recognize some familiar concepts, but the differences are
    significant.</p>

    <p>The general structure and timing of the Sync Channel
    Incremental system is both similar to and different from the
    GanymedeBuilderTask model.  As with GanymedeBuilderTask,
    synchronization is a two-step process.  In the first step, the
    Ganymede server writes out files with synchronization information.
    In the second step, an external process is initiated to
    incorporate that synchronization data into targeted services.  In
    the GanymedeBuilderTask model, both of these steps are scheduled
    to occur as soon as possible after a transaction is committed, and
    the second step follows immediately after the first.</p>

    <p>In the Sync Channel Incremental model, the first step of
    writing out the synchronization data is always done synchronously
    with the transaction commit process.  (So much so, in fact, that a
    transaction is not considered committed until all registered Sync
    Channels have finished writing out their synchronization files.)
    The second step is scheduled for asynchronous execution with the
    Ganymede Scheduler as soon as possible after a transaction is
    committed.  This usually means that the external synchronization
    will occur immediately, but if the Sync Channel is still executing
    a previous external synchronization, the external process for step
    two will not run until the previous run finishes.</p>

    <p>Because synchronization data may be written out with every
    transaction that is committed while the external processing step
    may execute after some delay, synchronization data can accumulate
    as it waits to be processed.  The Sync Channel Synchronization
    Model therefore acts as a message queuing system.  The message
    queue represents the 'channel' that gives the Sync Channel
    Incremental Model its name.</p>

    <p>The Sync Channel Incremental Model is designed to require less
    customization of the Ganymede server.  Where the
    GanymedeBuilderTask model requires adopters to write their own <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html#builderPhase1()">builderPhase1()</a>
    methods in order to write out custom data files, the Sync Channel
    Incremental system uses a standard XML format which is generated
    by standard logic in the <a
    href="../javadoc/arlut/csd/ganymede/server/SyncRunner.html">SyncRunner</a>
    class.  The external synchronization process must be smart enough
    to interpret the XML synchronization data, but it generally works
    out better to have this logic be outside of the Ganymede server,
    where it can more easily be maintained.</p>

    <p>You can create as many Sync Channels as you like in the
    Ganymede server, and each Sync Channel can be configured to
    include whatever subset of data you care about for that channel in
    particular.</p>

    <h4 id="configuring_sync_incremental">Configuring Sync Channels</h4>

    <p>All that you need to do to configure an incremental Sync
    Channel in Ganymede is to create a <code class="type">Sync
    Channel</code> object in the Ganymede server.  the <code
    class="type">Sync Channel</code> object has the following fields
    that you can set:</p>

    <ul>
      <li><code class="type">Name</code> -- The unique name for this
      Sync Channel.</li>

      <li><code class="type">Sync Channel Type</code> -- Your choice
      among 'Manual', 'Automatic Full State', and 'Automatic
      Incremental'.  These three choices correspond to the three Sync
      Channel synchronization models you can use in the Ganymede
      server.</li>

      <li><code class="type">Queue Directory</code> -- Path to the
      directory that the Ganymede server will write synchronization
      files into.  Only meaningful in incremental Sync Channels.</li>

      <li><code class="type">Full State File</code> -- Fully specified
      path to the file to which that the Ganymede server will write
      full state synchronization files.  Only meaningful in full state
      Sync Channels.</li>

      <li><code class="type">Service Program</code> -- Path to the
      executable external program that will process the
      synchronization files.  Meaningful for both incremental and full
      state Sync Channels.</li>

      <li><code class="type">Sync Data</code> -- Map of object and
      field types to the conditions under which they are (or are not)
      to be written to this Sync Channel.</li>

      <li>
	<code class="type">Allow Plaintext Passwords</code> --
	Check-box controlling whether or not password plaintext is
	allowed to be written to this Sync Channel.

	<br/>

	If this check-box is not selected, the Ganymede server will
	still permit stored password hashes to be written to the Sync
	Channel, but plaintext will be disallowed.  You might want to
	restrict plaintext passwords if you know that your Service
	Program doesn't need access to the plain text in order to
	synchronize passwords.

	<br/>

	See the <a
	href="../xml/data.html#PASSWORD">&lt;password&gt;</a> element
	guide for more details on password hashing vs. plaintext.
      </li>
    </ul>
 
    <p>An incremental <code class="type">Sync Channel</code> object
    looks like this:</p>

    <center><img src="screenshots/sync_channel.png" class="screenshot"/></center>

    <p id="sync_data">You configure the data that will be synchronized to the Sync
    Channel by editing the <code class="type">Sync Data</code> field
    with the Ganymede client.  For each type of object defined on your
    Ganymede server, you will see a check-box that lets you choose
    whether or not that kind of object should ever be synchronized to
    the Sync Channel.</p>

    <p>If you open up the folder for a given object type, you will be
    able to select three options for every field:</p>

    <ul>
      <li><b>Never</b> -- This field will never be synchronized to this Sync
      Channel, and whether or not the field was changed by a given
      transaction will have no effect on the decision as to whether or
      not to include the containing object in a synchronization
      file.</li>

      <li><b>When Changed</b> -- This field will be written to the Sync
      Channel whenever it changes.</li>

      <li><b>Always</b> -- This field will always be written to the
      Sync Channel, so long as at least one field in the containing
      object that is marked "Always" or "When Changed" was changed in
      the transaction.</li>
    </ul>

    <p>The <b>Always</b> option is intended to allow you to mark
    fields whose data must always be included in a synchronization
    file if the object itself is modified in any way significant to
    the Sync Channel.  If you know, for instance, that your Sync
    Channel service program will always need to know the contents of a
    user object's <code class="type">Username</code> field every time
    anything of significance in the object changes, you can configure
    your Sync Channel's <code class="type">Sync Data</code> to always
    include it when the object is significantly changed.</p>

    <p>A "significantly changed object," of course, means an object in
    which any field marked with <b>Always</b> or <b>When Changed</b>
    in the <code class="type">Sync Channel</code> definition was
    created, changed, or removed during the transaction.</p>

    <p>Here's an example of what you'll see when you edit a <code
    class="type">Sync Data</code> field in a <code class="type">Sync
    Channel</code> object.  This image shows a <code class="type">Sync
    Channel</code> object that is configured to write <code
    class="type">User</code> objects to the Sync Channel whenever any
    field but the <code class="type">Removal Date</code> and <code
    class="type">Expiration Date</code> fields change.  Whenever any
    such field changes, the object record in the synchronization file
    will include the <code class="type">Username</code> and the <code
    class="type">Notes</code> fields.</p>
      
    <center><img src="screenshots/sync_field_options.png" class="screenshot"/></center>

    <h4 id="what_xml_incremental_writes">What The Sync Channel Incremental Model Writes Out</h4>

    <p>The Ganymede server writes one XML file to the Sync Channel
    synchronization directory for each relevant transaction that is
    committed to the Ganymede server.  Each transaction is given a
    simple integer filename, unadorned with any filename extension.
    The Ganymede server maintains a transaction count for every
    transaction committed after the Ganymede server is initialized,
    the first transaction committed being transaction zero.</p>

    <p>Each file that is written out looks like this:</p>

    <xmp class="listing"><transaction major_version="1" minor_version="1" channel="Users" user="supergash" number="18" time="1111015745225">
  <object_delta>
    <before>
      <object type="User" id="barkerr" oid="3:1175">
        <Username>barkerr</Username>
        <Signature_Alias>barkerr</Signature_Alias>
      </object>
    </before>
    <after>
      <object type="User" id="freeman" oid="3:1175">
        <Username>freeman</Username>
        <Signature_Alias>freeman</Signature_Alias>
      </object>
    </after>
  </object_delta>
</transaction></xmp>

    <p id="transaction_element">The attributes in the &lt;transaction&gt; element are as follows:</p>

    <div align="center">
      <table border="1">
	<tr><th>Attribute</th><th>Value</th></tr>
	<tr><td><b>major_version</b></td><td>A major version number
	for the Ganymede Sync Channel transaction format.</td></tr>
	<tr><td><b>minor_version</b></td><td>A minor version number
	for the Ganymede Sync Channel transaction format.</td></tr>
	<tr><td><b>channel</b></td><td>The name of the Sync Channel
	that generated this XML file.</td></tr>
	<tr><td><b>user</b></td><td>The name of the Ganymede user or
	admin that committed this transaction.</td></tr>
	<tr><td><b>number</b></td><td>Unique number for this
	transaction, the number of transactions committed by this
	Ganymede server prior to this one.  Also the filename of this
	file.</td></tr>
	<tr><td><b>time</b></td><td>Java time code marking the time
	this transaction was written.  Interpreted as the number of
	milliseconds since Midnight, January 1, 1970 UTC.</td></tr>
      </table>
    </div>

    <p>Within the &lt;transaction&gt; element are a series of
    &lt;object_delta&gt; elements.  Each &lt;object_delta&gt; element
    contains a &lt;before&gt; element and an &lt;after&gt;
    element.</p>

    <p>The &lt;before&gt; and &lt;after&gt; elements contain one
    &lt;object&gt; element each.  These &lt;object&gt; elements are
    identical to the <a
    href="../xml/data.html#OBJECT">&lt;object&gt;</a> elements
    as they are used with the <a
    href="../glossary.html#xmlclient">xmlclient</a>, except that the <code
    class="attribute">oid</code> attribute has been added.  The <code
    class="attribute">oid</code> attribute may be useful to your Sync
    Channel service program as a foreign key, constant against object
    renames.  In the same way, the <code class="attribute">oid</code>
    attribute is added to the <a
    href="../xml/data.html#INVID">&lt;invid&gt;</a> element,
    strictly to act as a reliable reference in the face of object
    renames.</p>

    <p>The other big difference with the &lt;object&gt; elements in
    the Sync Channel XML output is that they will only include the
    fields that the <code class="type">Sync Channel</code> was
    configured to write.  This will usually just be fields that have
    changed.</p>

    <p class="note">There is yet a third difference, having to do with
    how embedded objects are handled.  In <a
    href="../glossary.html#xmlclient">xmlclient</a>'s normal output,
    embedded objects are embedded in place, while in Sync Channel
    output, embedded object trees are simply represented as flat lists
    of <a href="../xml/data.html#INVID">&lt;invid&gt;</b></a>
    elements.  This is pretty obscure, but if you're dealing with
    embedded objects in your Ganymede schema, you'll see what we
    mean.</p>

    <p>If a field did change during the transaction, its before state
    will be written in the &lt;before&gt; element, and its after state
    will be written in the &lt;after&gt; element.  If a field was
    newly created during the transaction, the field will not appear in
    the &lt;before&gt; element but it will appear in the &lt;after&gt;
    element.  Likewise, if a field was deleted during the transaction,
    it will appear in the &lt;before&gt; element but not in the
    &lt;after&gt; element.</p>

    <p>If an object is created or destroyed in a transaction rather
    than merely edited, the &lt;before&gt; or &lt;after&gt; elements,
    respectively, will be empty.</p>

    <p>Here's an example of a user in the laboratory's Ganymede server
    being deleted by the expiration task:</p>

<xmp class="listing"><transaction major_version="1" minor_version="1" channel="Users" user="expiration" number="21" time="1111730401435">
  <object_delta>
    <before>
      <object type="User" id="raghu" oid="3:1657">
        <Username>raghu</Username>
        <UID>3025</UID>
        <Global_UID>11f3a6c0-a9cd-11d8-b6ba-080020fd6b07</Global_UID>
        <Account_Category><invid type="User_Category" id="normal" oid="279:5"/></Account_Category>
        <Full_Name>Raj Raghu</Full_Name>
        <Badge>5917</Badge>
        <Division>ASD</Division>
        <Room>N347</Room>
        <Office_Phone>3872</Office_Phone>
        <Groups>
          <invid type="Group" id="asrmas" oid="257:143"/>
          <invid type="Group" id="omssys" oid="257:851"/>
        </Groups>
        <Home_Group><invid type="Group" id="asrmas" oid="257:143"/></Home_Group>
        <Login_Shell>/bin/bash</Login_Shell>
        <Home_Directory>/home/raghu</Home_Directory>
        <Directory_Volume>
          <invid type="Embedded_Automounter_Map_Entry" id="Embedded Automounter Map Entry[1810]" oid="278:1810"/>
        </Directory_Volume>
        <Signature_Alias>raghu</Signature_Alias>
        <Email_target>
          <string val="raghu@arlmail.arlut.utexas.edu"/>
        </Email_target>
        <Password_Expiration><date val="Tue, 08 Mar 2005 00:00:01" timecode="1110261601003"/></Password_Expiration>
        <Owner_list>
          <invid type="Owner_Group" id="ATL" oid="0:9"/>
        </Owner_list>
      </object>
    </before>
    <after/>
  </object_delta>
</transaction>
</xmp>

    <p>Notice that all fields that were contained in the object prior
    to the transaction commit and which match the <code
    class="type">Sync Data</code> constraints are included in the
    before state, while the after state is empty.  This is an
    ex-user.</p>

    <h4 id="xml_incremental_service_program">Writing a Sync Channel Incremental Service Program</h4>

    <p>Writing a Service Program for use with the Sync Channel
    Incremental Mode is generally rather more complicated than <a
    href="#external_builder">writing an external sync script for use
    with GanymedeBuilderTask</a>.  Your Service Program has to be able
    to cooperate with the Ganymede server in handling the message
    queuing protocol for your Sync Channel Queue Directory, and it has
    to be able to parse and process the XML written out by the
    Ganymede server.</p>

    <p>Here are the rules for a Sync Channel Incremental Service
    Program:</p>

    <ul>
      <li>As with the GanymedeBuilderTask external sync scripts, your
      Service Program is on its own with regard to setting up
      environment variables, working directory, logging/output
      streams, and locating files.  Your Service Program must be able
      to find its Queue Directory with no hints from the Ganymede
      server at runtime.</li>

      <li>The Ganymede server will run your Service Program with a
      single command line argument.  This will be the highest
      transaction number your Service Program is allowed to process
      during this run.  Any transactions with higher numbers that your
      Service Program may come across in the Sync Channel Queue
      Directory are not safe to operate on, as they may not be fully
      written or committed.  If they are fully written, they may later
      be withdrawn if the server runs into an I/O problem while
      writing XML to other configured Sync Channel Queue
      Directories.</li>

      <li>Your Service Program is required to process transactions in
      increasing numeric order.  Be careful to use a numeric sort and
      not a textual sort when ordering your processing.</li>

      <li>Your Service Program must process transactions.  This
      involves reading an XML transaction file from the Queue
      Directory, parsing and interpreting the XML record in terms of
      the Ganymede server schema, and performing the appropriate
      action on the target directory service to make the equivalent
      changes in the target service's schema.</li>

      <li>Your Service Program is responsible for removing
      successfully processed transactions from the Queue Directory.
      Your Service Program must only remove a transaction from the
      Queue Directory when it is certain that the change has been
      properly synchronized into the target service.  You may wish to
      move successfully committed transactions to another directory
      for record keeping (and the possibility of playback in the event
      of a rollback of your target service), or you may delete them
      from the Queue Directory entirely.  Your Service Program must
      not leave processed transactions in the Queue Directory.</li>

      <li>It is conceivable that your Service Progam may be
      interrupted or killed after it has completely processed a
      transaction and before it has cleared the transaction from the
      Queue Directory.  You must attempt to deal with this situation
      as cleanly as possible.  Ideally, your Service Program should be
      able to recognize that the target service is already compliant
      with the after state of a given transaction.  This should only
      ever happen with the first transaction your Service Program, as
      your Service Program should never start processing a transaction
      before it has cleared the previous transaction from the Queue
      Directory.</li>

      <li>If your Service Program encounters a transaction that it
      cannot process due to a transient error, it must stop processing
      transactions, and leave the failed transaction in the Queue
      Directory for processing by a later attempt.</li>

      <li>
	If your Service Program encounters a transaction that it
	cannot process due to a data mismatch with the target service,
	you must attempt to notify a human to take a look at the
	problem.  This may be through logging to a Service
	Program-specific log, by writing to a syslog service, by
	creating an SNMP trap, or by sending email.  Or all of the
	above, if you can.  Your Service Program must process no
	further transactions, and it must leave the problematic
	transaction in the Queue Directory for human examination.
	
	<br/><br/>
      
	This class of error should ideally never occur, if your
	Ganymede server schema and your Service Program and your
	target service are all properly compatible.
      </li>

      <li>If you can determine with confidence that certain classes of
      data mismatches are non-fatal and will not cause new problems to
      arise with future transactions, you may record a non-fatal error
      to your Service Program log, move the problematic transaction
      aside for human examination, and continue processing
      transactions.  You should be extraordinarily certain about your
      logic before doing this, however.</li>
    </ul>

    <p>As you can see, writing a Sync Channel Incremental Service
    Program can be quite involved.  To make it easier on you, we have
    written a Python package, SyncUtils, which knows how to set up
    logging, how to parse Ganymede XML transaction files, and how to
    identify what objects and fields were created, edited, and
    deleted.  Writing synchronization code with SyncUtils is as easy
    as writing a callback Python function that takes data from the
    SyncUtils package and works with it from there.</p>

    <h3 id="xml_full_state">2.2 The Sync Channel Full State Model</h3>

    <p>The Sync Channel Full State Model is a hybrid of the <a
    href="#xml_incrementals">Sync Channel Incremental</a> and the <a
    href="#buildertask">GanymedeBuilderTask</a> model.  Like the Sync
    Channel Incremental model, the Sync Channel Full State model uses
    a standardized XML format for writing out synchronization
    information.  Unlike the Sync Channel Incremental model, however,
    the full state model is automatically scheduled by the Ganymede
    server, in the same way that GanymedeBuilderTasks are.</p>

    <p>Precisely, what this means is that whenever a transaction is
    committed, each full state sync channel examines the transaction
    and determines whether that transaction contained any <a
    href="#sync_data">significantly changed objects</a>. If so, as
    soon thereafter as the GanymedeScheduler can manage, the Sync
    Channel's <a
    href="../javadoc/arlut/csd/ganymede/server/SyncRunner.html">SyncRunner</a>
    object will write out everything in the Ganymede Server which
    matches the Sync Channel's <code class="type">Sync Data</code>
    constraints to the defined <code class="type">Full State
    File</code>, and then run the defined external sync channel <code
    class="type">Service Program</code>.</p>

    <p>Here's what a Full State Sync Channel looks like:</p>

    <center><img src="screenshots/full_sync_channel.png" class="screenshot"/></center>

    <h4 id="xml_full_state_service_program">Writing a Sync Channel Full State Service Program</h4>

    <p>The Sync Channel Full State Service Program is similar to but
    simpler than the <a href="#xml_incremental_service_program">Sync
    Channel Incremental Service Program</a>.  In particular, the Full
    State Service Program is only required to deal with a single XML
    file, whose full filename is provided to the Full State Service
    Program as its sole command line argument.</p>

    <p>The only real rule that applies is that the Full State Service
    Program is required to be fully self sufficient about setting up
    paths, working directories, and any necessary environment
    variables.  The only thing the Full State Service Program is given
    is a filename that the Full State Service Program must open and
    read on its own.</p>

    <p>Here's an example of the sort of XML file that the Full State
    Service Program must be prepared to process:</p>

    <xmp class="listing"><ganymede major="1" minor="0">
  <ganydata>
    <object type="User" id="jonabbey" oid="3:1143">
      <Username>jonabbey</Username>
      <UID>6074</UID>
      <Global_UID>7cea5c0d-7a22-11d8-a1a0-080020fd6b07</Global_UID>
      <Password><password crypt="zv16nogZ9eRP5" md5crypt="$1$bH3vxykP$dkmWhIdVuqC8Y1h0s7PQU1" lanman="8AF317306D28CA711D0DC6E\
72A9441BB" ntmd4="D3A6370C044FD34C6A487A6F5F53A6C1" ssha="{SSHA}cdHEG7iIMT2ZSHkJEf4fR62v/b23rnMO"/></Password>
      <Account_Category><invid type="User_Category" id="normal" oid="279:5"/></Account_Category>
      <Full_Name>Jonathan Abbey</Full_Name>
      <Badge>x819</Badge>
      <Division>ITS</Division>
      <Room>S321</Room>
      <Office_Phone>835-3199</Office_Phone>
      <Groups>
        <invid type="Group" id="omssys" oid="257:245"/>
        <invid type="Group" id="csdweb" oid="257:114"/>
        <invid type="Group" id="omrgen" oid="257:264"/>
      </Groups>
      <Home_Group><invid type="Group" id="omssys" oid="257:245"/></Home_Group>
      <Login_Shell>/bin/tcsh</Login_Shell>
      <Home_Directory>/home/jonabbey</Home_Directory>
      <Directory_Volume>
      <object type="Embedded_Automounter_Map_Entry" id="Embedded Automounter Map Entry[1257]" oid="278:1257">
        <Automounter_Map><invid type="Automounter_Map" id="auto.home.default" oid="277:2"/></Automounter_Map>
        <NFS_Volume><invid type="NFS_Volume" id="omg2" oid="276:636"/></NFS_Volume>
      </object>
      </Directory_Volume>
      <Email_Aliases>
        <string val="abbey"/>
      </Email_Aliases>
      <Signature_Alias>jonabbey</Signature_Alias>
      <Email_target>
        <string val="jonabbey@arlmail.arlut.utexas.edu"/>
      </Email_target>
      <Password_Expiration><date val="Tue, 03 May 2005 07:57:22" timecode="1115125042144"/></Password_Expiration>
      <Owner_list>
        <invid type="Owner_Group" id="ITS" oid="0:9"/>
       </Owner_list>
    </object>
  </ganydata> 
</ganymede></xmp>

    <p>The particulars of this XML schema is dependent on the
    particular schema configured in the Ganymede server.  Field names
    come straight from the Ganymede server's schema, with a simple <a
    href="../xml.html#underscore">spaces to underscores</a> encoding
    to make sure that field names cohere with proper XML specs.</p>

    <p>Notice that this format is basically identical to the output of
    an <a href="../xml/xmlclient.html">xmlclient</a> data object dump,
    as documented in the <a href="../xml/data.html">Ganymede XML
    &lt;ganydata&gt; Guide</a>.</p>

    <h3 id="xml_manual">2.3 The Sync Channel Manual Model</h3>

    <p>The Sync Channel Manual model is based on the <a
    href="#xml_full_state">Sync Channel Full State Model</a>.
    Unlike the <a href="#buildertask">GanymedeBuilderTask</a> and <a
    href="#xml_full_state">Sync Channel Full State</a> models, the
    Sync Channel Manual model is not supported by the Ganymede server
    as an automated build system.</p>

    <p>Instead, the Sync Channel Manual model refers to the ability to
    use the <a href="../xml/xmlclient.html">xmlclient</a> to dump out
    a subset of the Ganymede datastore, using a <a
    href="#configuring_sync_incremental">Sync Channel</a> object to
    constrain the object and field types dumped.  The idea is that,
    after dumping out your information using <a
    href="../xml/xmlclient.html">xmlclient</a>, you use a variant of
    the <a href="#xml_incremental_service_program">Sync Channel
    Incremental Service Program</a> to synchronize the full state of
    your Ganymede data with your target directory service.</p>

    <p>The SyncUtils Python package that we have written knows how to
    read a Ganymede full state and/or manual XML dump, and can support
    you in doing manual full state synchronization.</p>

    <p>To generate a Sync Channel manual dump, you can run:</p>

    <xmp class="listing">xmlclient -dumpdata sync=Users > user_full_state.xml</xmp>

    <p>The output of such a <code>xmlclient -dumpdata</code> command
    is identical to that produced by the <a
    href="#xml_full_state">Sync Channel Full State Model</a>, and can
    be processed by any service program that is compatible with the
    requirements of the <a href="#xml_full_state_service_program">Sync
    Channel Full State Service Program</a>.</p>

    <p>Here is a screenshot of a Sync Channel configured for manual
    operation:</p>

    <center><img src="screenshots/manual_sync_channel.png" class="screenshot"/></center>

    <p>Note, however, that you can do this <code>xmlclient</code> dump
    trick with any Sync Channel that you have registered in your
    Ganymede server.  Actually configuring a Sync Channel as
    <code>Manual</code> is strictly optional, and would generally only
    be done when you know that you don't want the server ever to
    automatically generate an incremental or full state build for you
    using the Sync Channel.</p>

    <hr/>
    <address><a href="mailto:jonabbey@arlut.utexas.edu">Jonathan Abbey</a></address>
    <p class="address">$Date$, $Rev$, $Author$</p>
  </body>

</html>
