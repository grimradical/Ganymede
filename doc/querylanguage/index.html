<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../stylesheets/ganymede.css"/>
    <title>Ganymede Query Language Quide</title>
  </head>

  <body>
    <div id="header">
      <IMG SRC="../gifs/ganymede_title.gif" alt="Ganymede Logo"/>

      <div id="title">
        <h1>Ganymede 2.0 Query Language Guide</h1>
        <p>Release 2.0 dev - ? ? 2005<br/>$Rev$</p>
      </div>

      <div id="abstract">
        <p>A description of the simple SQL-like Ganymede Query
        Language (GanyQL) supported by Ganymede 2.0.</p>

        <p>Starting with version 2.0, Ganymede supports a simple
        textual query language to represent queries against the
        Ganymede data store.  The Ganymede server incorporates a
        translator to turn queries specified in the new Ganymede Query
        Language (GanyQL) into the old-school linked tree
        representation that Ganymede has always supported behind the scenes.</p>

        <p> Programmers writing code directly to the internal Ganymede
        API can make use of GanyQL to simplify their coding on plugins
        and the like and, best of all, end users can make use of
        GanyQL directly from the command line using the Ganymede 2.0
        <a href="../xml/xmlclient.html">xmlclient</a>.</p>
      </div>

      <p>by <a href="mailto:jonabbey@arlut.utexas.edu">Jonathan
      Abbey</a>, GanyQL designed and implemented by <a
      href="mailto:deepak@brownman.org">Deepak Giridharagopal</a>.</p>
    </div>

    <h2>Introduction</h2>

    <p>In Ganymede 1.0, the only way to query the Ganymede data store
    was to manually create a Ganymede <a
    href="../javadoc/arlut/csd/ganymede/common/Query.html">arlut.csd.ganymede.common.Query</a>
    object with a linked tree of <a
    href="../javadoc/arlut/csd/ganymede/common/QueryNode.html">arlut.csd.ganymede.common.QueryNode</a>
    objects representing the query's exploded parse tree.  Programming
    queries into the Ganymede server was difficult, and creating shell
    scripts to pull arbitrary data from the Ganymede server was simply
    impossible.  Any queries, no matter how simple, required the
    creation of custom Java code to assemble the appropriate
    structured query trees.</p>

    <p>To bring light into this darkness, Ganymede 2.0 introduces a
    simple new Ganymede Query Language called <span
    class="definition">GanyQL</span>.  GanyQL is very loosely
    patterned after SQL syntax, and is designed to make it possible to
    express queries on the Ganymede data store in a human-readable and
    direct fashion.  All you need to do is write a bit of GanyQL and
    parsing code on the Ganymede server will take care of translating
    your request into the Ganymede query engine's internal
    structure.</p>

    <p>GanyQL was designed and implemented by Deepak Giridharagopal
    using Terrance Parr's excellent <a
    href="http://www.antlr.org/">ANTLR</a> parser generation system.
    If you ever find yourself needing to incorporate language parsing
    into your development project, we recommend ANTLR to you without
    reservation.  It is a superb tool.</p>

    <h2>What it looks like</h2>

    <p>Here are some examples of what GanyQL queries look like:</p>

    <div class="example">
      <p><code><span class="keyword">select object from editable</span> "User" <span class="keyword">where</span> "UID" <span class="keyword">&gt;=</span> 2000</code></p>
      <p><code><span class="keyword">select</span> "Username","UID" <span class="keyword">from editable</span> "User"</code></p>
      <p><code><span class="keyword">select</span> "Username" <span class="keyword">from</span> "User" <span class="keyword">where</span> "Expiration Date" <span class="keyword">defined</span></code></p>

      <p><code><span class="keyword">select</span> "GroupName","GID" <span class="keyword">from</span> "Group" <span class="keyword">where</span> "Owner List" <span class="keyword">=~_ci</span> "^csd"</code></p>

      <p><code><span class="keyword">select</span> "Username","UID","Home Group" <span class="keyword">from editable</span> "User"
      <span class="keyword">where</span> "Home Group"<span class="keyword">-&gt;(</span>"GID" <span class="keyword">>=</span> 2000 <span class="keyword">and</span> "GID" <span class="keyword">&lt;=</span> 8000<span class="keyword">)</span></code></p>

      <p><code><span class="keyword">select</span> "Name" <span class="keyword">from</span> "Owner Group" <span class="keyword">where</span> "Admin
       Persona"<span class="keyword">-&gt;</span>"User"<span class="keyword">-&gt;</span>"Home Group"<span class="keyword">-&gt;</span>"Users" <span class="keyword">len&lt;=</span> 5</code></p>
    </div>

    <p>In English, these queries are as follows:</p>

    <ol>
      <li>Return all user objects in the Ganymede server that I have
      permission to edit whose UID field contains a value greater than
      or equal to 2000.</li>

      <li>Return a list of user names and uids for all users in the
      Ganymede server that I have permission to edit.</li>

      <li>Return a list of user names for all users in the Ganymede
      server that I have permission to read and which have a non-empty
      Expiration Date field.</li>

      <li>Return a list of GroupName and GIDs for all groups in the
      Ganymede server that I have permission to read and whose Owner
      List field contains one or more strings which match '^csd' using
      a case-insensitive regular expression match.</li>

      <li>Return a list of Usernames, UIDs and Home Groups for users
      in the Ganymede server that I have permission to edit and whose
      Home Group field points to a Group object whose GID field is
      between 2000 and 8000, inclusive.</li>

      <li>Return a list of Names for Owner Group objects in the
      Ganymede server that I have permission to read and whose Admin
      Persona field points to an admin persona whose User field points
      to a user whose Home Group field points to a group whose Users
      field has five or fewer users in it.</li>
    </ol>

    <p>As you can see from these examples, you can express some quite
    involved queries with a very little bit of GanyQL.</p>

    <p>As powerful as it is, and as much as the syntax is designed to
    look like SQL, GanyQL is really very different.  Queries are made
    on objects, not tables, and you can't get back data from multiple
    kinds of objects with a single query.  You can express queries and
    subqueries that traverse Ganymede's object pointer (invid) fields,
    though, which makes up somewhat for the lack of table joins and
    the like.</p>

    <h2>The syntax</h2>

    <p class="note">To fully express the syntax of GanyQL would
    require an exposition as long and precise as the actual <a
    href="query.g">GanyQL grammar</a>.  If you've had any experience
    with abstract syntax definitions, you may find grammar to be the
    most clear and concise statement of the GanyQL language.</p>

    <h3>Gross Structure</h3>

    <p>The GanyQL syntax is reasonably simple.  All queries in GanyQL
    have this general structure:</p>

    <div class="example"><span class="keyword">select</span> <i>return values</i> <span class="keyword">from</span> <span class="optkeyword">editable</span> "<i>Object Type</i>" <span class="optkeyword">where</span> <i>test expression</i></div>

    <p>The words in <span class="keyword">boldface</span> are keywords
    that must be typed in lower case, exactly as they appear here.
    Words in <span class="optkeyword">italic boldface</span> are
    optional, and text in <i>plain italics</i> are where you will have
    to provide input.</p>

    <p>The "<i>Object Type</i>" string is the name of the type of
    object in the Ganymede data store that you want to query.  As with
    all strings you use in GanyQL, you'll need to surround the name of
    the object type in either single or double quotation characters,
    and you'll need to be sure you've got the capitalization
    right.</p>

    <p>The <i>return values</i> can either be the single keyword <span
    class="optkeyword">object</span>, if you want to get back all
    fields from the object, or a comma separated list of field name
    strings that you want to retrieve from "<i>Object Type</i>".</p>

    <p>The <span class="optkeyword">editable</span> keyword is
    optional.  If it is present, the query will only examine and
    return objects that you have permission to check out for editing.
    If <span class="keyword">editable</span> is not present, the query
    will match against all objects of the appropriate type that you
    have permission to view.</p>

    <p>Finally, there's the optional <span
    class="optkeyword">where</span> clause.  If you do not provide a
    where clause, all objects of the appropriate Object Type that you
    have permission to see and/or edit will be returned.</p>

    <h3>The Where Clause</h3>

    <p>If you do provide a where clause, you can place specific
    restrictions on the objects you are interested in querying.</p>

    <p>The where clause consists of the keyword <span
    class="keyword">where</span> followed by a logical combination of
    field tests.  These tests are specified using simple operators,
    and can be combined using the logical operators <span
    class="keyword">and</span>, <span class="keyword">or</span>, and
    <span class="keyword">not</span>.  You can also use parentheses to
    control the grouping of expressions.</p>

    <p>The field tests supported by GanyQL are listed in the following table:</p>

    <table><caption>Field Test Operators</caption>
      <tr><th>Operator</th><th>Meaning</th><th>Field Types</th><th>Argument Types</th></tr>
      <tr>
        <td><span class="keyword">=~</span></td>
        <td>Regular Expression Match</td>
        <td>Invid, I.P. Address, String</td>
        <td>Regular Expression</td>
      </tr>
      <tr>
        <td><span class="keyword">=~_ci</span></td>
        <td>Regular Expression Match (case insensitive)</td>
        <td>Invid, I.P. Address, String</td>
        <td>Regular Expression</td>
      </tr>
      <tr>
        <td><span class="keyword">==</span></td>
        <td>Equality</td>
        <td>Boolean, Date, Float, Invid, I.P. Address, Number, String</td>
        <td>String, Date, Booleans, Numeric, I.P.&nbsp;Address</td>
      </tr>
      <tr>
        <td><span class="keyword">==_ci</span></td>
        <td>Equality (case insensitive)</td>
        <td>Invid, I.P. Address, String</td>
        <td>String, Date, Booleans, Numeric, I.P.&nbsp;Address</td>
      </tr>
      <tr>
        <td><span class="keyword">&lt;</span></td>
        <td>Less Than</td>
        <td>Date, Float, Invid, Number, String</td>
        <td>String, Date, Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">&lt;=</span></td>
        <td>Less Than or Equal</td>
        <td>Date, Float, Invid, Number, String</td>
        <td>String, Date, Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">&gt;</span></td>
        <td>Greater Than</td>
        <td>Date, Float, Invid, Number, String</td>
        <td>String, Date, Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">&gt;=</span></td>
        <td>Greater Than or Equal</td>
        <td>Date, Float, Invid, Number, String</td>
        <td>String, Date, Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">starts</span></td>
        <td>Begins With</td>
        <td>Invid, I.P. Address, String</td>
        <td>String</td>
      </tr>
      <tr>
        <td><span class="keyword">ends</span></td>
        <td>Ends With</td>
        <td>Invid, I.P. Address, String</td>
        <td>String</td>
      </tr>
      <tr>
        <td><span class="keyword">len&lt;</span></td>
        <td>Array Length Less Than</td>
        <td>Any array field</td>
        <td>Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">len&lt;=</span></td>
        <td>Array Length Less Than or Equal</td>
        <td>Any array field</td>
        <td>Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">len&gt;</span></td>
        <td>Array Length Greater Than</td>
        <td>Any array field</td>
        <td>Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">len&gt;=</span></td>
        <td>Array Length Greater Than or Equal</td>
        <td>Any array field</td>
        <td>Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">len==</span></td>
        <td>Array Length Equality</td>
        <td>Any array field</td>
        <td>Numeric</td>
      </tr>
      <tr>
        <td><span class="keyword">defined</span></td>
        <td>Field is defined (not empty)</td>
        <td>All</td>
        <td>n/a</td>
      </tr>
    </table>

    <p>and they can be combined with the following operators:</p>

    <table><caption>Logical Operators</caption>
      <tr><th>Operator</th><th>Meaning</th></tr>
      <tr>
        <td><span class="keyword">and</span></td>
        <td>Logical AND</td>
      </tr>
      <tr>
        <td><span class="keyword">or</span></td>
        <td>Logical OR</td>
      </tr>
      <tr>
        <td><span class="keyword">not</span></td>
        <td>Logical Negation</td>
      </tr>
      <tr>
        <td><span class="keyword">(&nbsp;)</span></td>
        <td>Grouping</td>
      </tr>
    </table>


    <p>Most of these operators take a pair of arguments, with the name
    of the field to look at before the operator and a value to compare
    the field to after the operator.  The two exceptions to this
    pattern are the <span class="keyword">defined</span> operator,
    which does not require or accept a second parameter, and the <span
    class="keyword">-&gt;</span> operator, which allows you to execute
    subqueries against objects pointed to by an object pointer/invid
    field.</p>

    <h3>GanyQL Examples</h3>

    <h2>Using GanyQL</h2>

    <p>Support for GanyQL has been introduced into the primary <a
    href="../javadoc/arlut/csd/ganymede/rmi/Session.html">Session</a>
    RMI interface used to communicate with the Ganymede server.</p>

  </body>
</html>
