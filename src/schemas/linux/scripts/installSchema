#!/opt/bin/perl5
#
# Schema install script for Ganymede
#
# $Name:  $
# $Revision: 1.1 $
# $Date: 1999/08/27 17:16:19 $
#
# Jonathan Abbey - jonabbey@arlut.utexas.edu
#
############################################################

use File::Copy;
use English;

if ($#ARGV != 2) {
    exit "Usage: $0 <schemakit-directory> <install-directory> <server-directory>\n";
}

sub installSchema {
my ($schemadir, $installdir, $serverdir) = (@_);

@steps = ("HOMEDIRPREFIX");

%vars = ("HOMEDIRPREFIX" => "/home/");

%descrip = ("HOMEDIRPREFIX" => "What prefix should be prepended to the user's name for their UNIX home directory?");

$template = "$schemadir/scripts/schema.properties.template";

# We don't want to hold back stdout

$| = 1;

####################

print <<ENDINTRO;

Linux Schema Kit Install Script
    -------------------------------

    ENDINTRO

####################

# Make sure we're running from the right directory

    open TEST, $template or $failure = 1;

if (!$failure) {
    close TEST;
} else {
    print "*error* couldn't find schema properties template.  bad $schemadir?\n";
    exit;
}

foreach $step (@steps) {

    $success = 0;

    while (!$success) {
	print $descrip{$step};
	print " [$vars{$step}] ";

	$inp = <>;

	chop $inp;		# cut off newline

	if ($inp ne "") {
	    $vars{$step} = $inp;
	}

	# We won't force the user to specify one of our schemas but
	# everything else they've gotta give us something

	if ($vars{$step}eq "") {
	    $success = 0;
	    print "*You must provide a value for this field*\n";
	} else {	
	    $success = 1;
	}
    }

# Ok, we've got everything

    print <<ENDCONFIG;

    Testing configuration information

	ENDCONFIG

	    $success = 1;	# Assume success until we find out otherwise

# can we make the schema install directory?

    if (! -d $installdir) {
	&removelastslash($installdir);
	mkdir($installdir, 0750) or die "*Couldn't make the server install directory*\n"; 
	print "Made the schema install directory ok\n";
    } else {
	print "Found the schema install directory ok\n";
    }

    print "\nConfiguration seems to check out.\n\n";
    print "Installing";

    &copydir($schemadir, $installdir); print ".";

# copydir doesn't preserve permissions.. make sure the schema build
# scripts are executable

    if ($schemainstalled) {
	chmod 0750, "$installdir/custom_src/build";
	chmod 0750, "$installdir/custom_src/rebuild";
	chmod 0750, "$installdir/custom_src/buildCustomJar";
	chmod 0750, "$installdir/loader/source/build";
    }

# Copy and process the properties file into place

    %propconvert = ("ganymede.homedirprefix" => $vars{"HOMEDIRPREFIX"});

    open INPUT, $template or die "Couldn't open properties template!";
    open OUTPUT, ">$installdir/schema.properties" or die "Couldn't write schema.properties";

    print "\nCustomizing schema.properties\n";

    while (<INPUT>) {

	if (!/^([^\#=]*)=/) {
	    print OUTPUT $_;
	} elsif (defined $propconvert{$1}) {
	    print OUTPUT "$1=$propconvert{$1}\n";
	} else {
	    print "Error.. unrecognized template entry $1 - copying template value\n";
	    print OUTPUT $_;
	}
    }

    close INPUT;
    close OUTPUT;

######################################################################
#
#  At this point we write out our mini-install guide for the user.
#
######################################################################

    open OUTPUT, ">$installdir/README.custom" or die "Couldn't create custom install instructions"; 

    if ($vars{"SCHEMA"} eq "linux") {

	print OUTPUT <<ENDLINUX;

	------------------------------

	    The Linux Schema Kit was successfully installed in $installdir.

		In order to get started with Ganymede, you need to do the following:

		1. Run the data loader to create a loader.db file from your passwd and group files.

		    a.   cd $installdir/loader
			b.   cp /etc/passwd /etc/group $installdir/loader/input
			    c.   Run ./runDirectLoader
				d.   If runDirectLoader succeeds, you\'ll have a loader.db file in
				    $installdir/loader/db/loader.db
					e.   cp $installdir/loader/db/loader.db $serverdir/db/ganymede.db

					    2. [OPTIONAL] Create a linux_builder script in $installdir/db.

						If you want Ganymede to actually update your passwd and group files in /etc,
						you can copy $installdir/linux_builder.sample to
						    $serverdir/db/linux_builder.  If you do this, the Ganymede
							server will copy the passwd and group files generated by changes in
							    Ganymede to /etc.  Take a look at the linux_builder.sample script before
								doing this, and make back-up copies of your original /etc/passwd and /etc/group
								    files, just in case.  These shouldn\'t be called /etc/passwd.old and /etc/group.old,
								    as Ganymede will overwrite these.

									2. Start the server up with your new ganymede.db file.

									    a.   cd $serverdir/bin
										b.   Run ./runServer

										    Your Ganymede server should now be running and ready to accept
											connections from the client and/or the admin console.

											    ------------------------------
												ENDLINUX
												}

######################################################################### 
#
#                                                                 makedir
#
# input: 1) a directory to make
#        2) octal chmod bits
#
######################################################################### 
    sub makedir{
	my ($dirpath, $chmod) = @_;

	if (!-e $dirpath) {
	    mkdir ($dirpath, $chmod) or die("*Couldn't make $dirpath*");
	}
    }

######################################################################### 
#
#                                                                 copydir
#
# input: 1) a directory to copy from
#        2) directory target
#
######################################################################### 
    sub copydir{
	my ($source, $target) = @_;
	my (@dirs, $file);

	&removelastslash($source);
	&removelastslash($target);

	if (!-e $target) {
	    &makedir($target, 0750);
	}

	opendir SOURCE, $source || die "Failure in copydir";
	@dirs = readdir SOURCE;
	closedir SOURCE;

	foreach $file (@dirs) {
	    if (($file eq ".") || ($file eq "..")) {
		next;
	    }

	    if (-d "$source/$file") {
		&copydir("$source/$file", "$target/$file"); #recurse
	    } else {
		copy("$source/$file", "$target/$file");
	    }
	}
    }

######################################################################### 
#
#                                                         removelastslash
#
# input: a pathname to test
#
# this function will remove a trailing slash from the directory name 
# input
#
######################################################################### 
    sub removelastslash{
	if ($_[0] =~ /\/$/) {
	    chop $_[0];
	}
    }
