# DBObjectBases.properties
#
# A default localization file for the Ganymede server
#
# Note: All single quotes must be doubled for escaping.. so "can't" becomes "can''t".
#
# Created: 3 September 2004
#
# Last Revision Changed: $Rev: 6941 $
# Last Changed By: $Author: broccol $
# Last Mod Date: $Date: 2005-06-24 23:31:48 +0200 (Fri, 24 Jun 2005) $
# SVN URL: $HeadURL: http://tools.arlut.utexas.edu/svn/ganymede/trunk/ganymede/src/resources/arlut/csd/ganymede/server/DBObjectBase.properties $

#
# global
#

#global.notediting = not in a schema editing context
global.notediting = Nicht im Kontext "Schema bearbeiten"
#global.default_tab = General
global.default_tab = Allgemein

#
# receive
#

#receive.basename = DBObjectBase.receive(): object base name: {0}
receive.basename = DBObjectBase.receive(): Objekt-Basis Name: {0}
#receive.rewritingClassname = DBObjectBase.receive(): Rewriting old system class name: {0} as {1}
receive.rewritingClassname = DBObjectBase.receive(): Überschreibe alten Systemklassennamen {0} mit {1}

#
# setXML
#

#setXML.baddoc = DBObjectBase.setXML(): root element != open objectdef: {0}
setXML.baddoc = DBObjectBase.setXML(): Rootelement != open objectdef: {0}
#setXML.missingname = DBObjectBase.setXML(): objectdef missing name attribute:\n {0}
setXML.missingname = DBObjectBase.setXML(): objectdef fehlendes Name-Attribut:\n {0}
#setXML.missingid = DBObjectBase.setXML(): objectdef missing id attribute:\n {0}
setXML.missingid = DBObjectBase.setXML(): objectdef fehlendes id-Attribut:\n {0}
#setXML.noid = Field definition missing name and/or id: {0}
setXML.noid = Felddefinition enthält keinen Namen/Id: {0}
#setXML.dupfieldname = More than one field in objectdef: {0}\ncontains field name {1}
setXML.dupfieldname = Mehr als ein Feld in objectdef {0}\nhat den Feldnamen {1}
#setXML.sysfield = Can''t set a field:\n{0}\nwith the same name as a pre-existing built-in field in objectdef:\n{1}
setXML.sysfield = Kann Feld\n{0}\n nicht mit dem gleichen Namen wie ein vordefiniertes Feld bezeichnen! objectdef:\n{1}
#setXML.noglobals = Can''t modify or set a field:\n{0}\nwith a field id in the global field range:\n{1}
setXML.noglobals = Kann Feld {0} nicht mit einer id aus dem globalen Feldbereich {1} versehen.
#setXML.dupfieldid = More than one field in objectdef: {0}\ncontains field id {1}
setXML.dupfieldid = Mehr als ein Feld in objectdef {0}\nbesitzt die Feldid {1}
#setXML.deleting = \t\tDeleting field {0}
setXML.deleting = \t\tLösche Feld {0}
#setXML.dupclassdef = Objectdef contains more than one classdef element:\n{0}
setXML.dupclassdef = Objectdef enthält mehr als ein classdef-Element:\n{0}
#setXML.duplabel = Objectdef contains more than one label element:\n{0}
setXML.duplabel = Objectdef enthält mehr als ein label-Element:\n{0}
#setXML.editing = \t\tEditing field {0}
setXML.editing = \t\tBearbeite Feld {0}
#setXML.unrecognized = Unrecognized XML item: {0} in objectdef:\n{1}
setXML.unrecognized = Unbekannter XML Begriff {0} in objectdef:\n{1}
#setXML.mysteryfield = Couldn''t find field {0} while resorting customFields.
setXML.mysteryfield = Kann Feld {0} beim Sortieren der customFields nicht finden.
#setXML.inconsistent = Consistency error while resorting customFields in base {0}
setXML.inconsistent = Konsistenzfehler beim Sortieren der customFields von Basis {0}
#setXML.consistencyerror = Consistency error while resorting customFields.
setXML.consistencyerror = Konsistenzfehler beim Sortieren der customFields.

#setXML.debugroot = Setting XML for object Base..{0}
setXML.debugroot = Erzeuge XML für Objekt-Basis... {0}
#setXML.debugid = Setting id
setXML.debugid = Setze id
#setXML.debugscanning = Scanning fields
setXML.debugscanning = Überprüfe Felder
#setXML.debugdels = Calculating fields to delete
setXML.debugdels = Bestimme zu löschende Felder
#setXML.debugnew = Setting XML on new field {0}
setXML.debugnew = Erzeuge XML für neues Feld {0}
#setXML.debuglabel = Setting label field
setXML.debuglabel = Setze label-Feld
#setXML.debugclass = Setting class name
setXML.debugclass = Erzeuge Klassennamen
#setXML.debugname = Setting object name
setXML.debugname = Erzeuge Objektnamen
#setXML.debugsorting = Sorting fields
setXML.debugsorting = Sortiere Felder
#setXML.debugdone = Done processing object base {0}
setXML.debugdone = Bearbeitung der Objekt-Basis {0} abgeschlossen

#
# createHook
#

#createHook.noclass = DBObjectBase.createHook(): class definition could not be found: {0}
createHook.noclass = DBObjectBase.createHook(): Klassendefinition nicht gefunden: {0}

#
# createNewObject
#

#createNewObject.noeditset = null editset in createNewObject
createNewObject.noeditset = editset ist Null in createNewObject
#createNewObject.badinvid = bad invid chosen in createNewObject: num already taken
createNewObject.badinvid = Falsche Invid in createNewObject: bereits vergeben
#createNewObject.badslottype = bad chosen_slot passed into createNewObject: bad type
createNewObject.badslottype = Falscher chosen_slot an createNewObject übergeben: Falscher Typ
#createNewObject.badslotnum = bad chosen_slot passed into createNewObject: num already taken
createNewObject.badslotnum = Falscher chosen_slot an createNewObject übergeben: Nummer bereits vergeben
#createNewObject.failure1 = createNewObject failure: {0} in trying to construct custom object
createNewObject.failure1 = createNewObject Abbruch: {0} beim Versuch, Custom-Objekt zu erzeugen
#createNewObject.failure2 = createNewObject failure: {0} in trying to check out custom object
createNewObject.failure2 = createNewObject Abbruch: {0} beim Versuch, Custom-Objekt auszuchecken

#
# setName
#

#setName.norename = Can''t rename base {0} to {1}, that name is already taken.
setName.norename = Kann Basis nicht von {0} nach {1} umbenennen. Der Name wird schon benutzt.

#
# setClassInfo
#

#setClassInfo.internalError = Internal RemoteException in setClassInfo: {0}
setClassInfo.internalError = Interne RemoteException in setClassInfo: {0}

#setClassInfo.noclass = Couldn''t find class {0} in the server''s CLASSPATH.  This probably means that you have not yet rebuilt \
#the custom.jar file with this class added.
setClassInfo.noclass = Kann Klasse {0} nicht im CLASSPATH des Servers finden. Das bedeutet wahrscheinlich, dass Sie custom.jar nicht um die Klasse erweitert und neu erzeugt haben.

#setClassInfo.noclassoption = Couldn''t load custom management logic from class {0} using class option string ''\
#{1}''.\n\nThis may mean that you have not yet rebuilt the custom jar file with the {0} class added, or that \
#the resource specified in the option string can not be found by {0}''s factory methods.
setClassInfo.noclassoption = Kann custom management logic aus Klasse {0} mittels class option string ''{1}'' nicht laden.\n\n Das kann bedeuten, dass Sie custom.jar nicht um die Klasse {0} erweitert und neu erzeugt haben, oder, dass \
die im option string angegebene Resource durch die Methoden der Klasse {0} nicht gefunden werden kann.

#
# moveFieldAfter
#

#moveFieldAfter.nomove = Error, can''t move field {0}, no such field in object type.
moveFieldAfter.nomove = Fehler: Kann Feld {0} nicht verschieben. Feld existiert im Objekt-Typ nicht.
#moveFieldAfter.nofield = Error, can''t move field {0} after {1}, no such field in object type.
moveFieldAfter.nofield = Fehler: Kann Feld {0} nicht hinter {1} verschieben. Feld existiert im Objekt-Typ nicht.

#
# moveFieldBefore
#

#moveFieldBefore.nomove = Error, can''t move field {0}, no such field in object type.
moveFieldBefore.nomove = Fehler: Kann Feld {0} nicht verschieben. Feld existiert im Objekt-Typ nicht.
#moveFieldBefore.nofield = Error, can''t move field {0} before {1}, no such field in object type.
moveFieldBefore.nofield = Fehler: Kann Feld {0} nicht vor {1} verschieben. Feld existiert im Objekt-Typ nicht.

#
# setTypeID
#

#setTypeID.notypemutation = Can''t change the type_code for an existing object base
setTypeID.notypemutation = Kann type_code für eine bestehende Objekt-Basis nicht ändern
#setTypeID.typeconflict = Can''t set the type_code for object base {0} to that of an existing object base
setTypeID.typeconflict = Kann den type_code für Objekt-Basis {0} nicht auf den einer bestehenden Objekt-Basis ändern

#
# setLabelField
#

#setLabelField.badfieldname = setLabelField() called with an unrecognized field name.
setLabelField.badfieldname = setLabelField() wurde mit einem unbekannten Feldnamen aufgerufen.
#setLabelField.badfieldid = setLabelField() called with an unrecognized field id.
setLabelField.badfieldid = setLabelField() wurde mit einer unbekannten Feld-Id aufgerufen.
#setLabelField.nonamespace = Error, label fields must be namespace-constrained.
setLabelField.nonamespace = Fehler: Label-Felder müssen über Namespaces eingeschränkt werden.

#
# createNewField
#

#createNewField.noluck = Couldn''t create field due to initialization error: {0}
createNewField.noluck = Kann Feld aufgrund von Initialisierungsfehler nicht erzeugen: {0}
#createNewField.defaultname = New Field
createNewField.defaultname = Neues Feld

#
# deleteField
#

#deleteField.fieldused = deleteField() called on object type {0} with a field name ({1}) that is in use in the database.
deleteField.fieldused = deleteField() wurde für Objekt-Typ {0} mit Feldname {1} aufgerufen. Dieser wird in der Datenbank verwendet.
#deleteField.fieldunknown = deleteField() called on object type {0} with an unrecognized field name ({1}).
deleteField.fieldunknown = deleteField() wurde für Objekt-Typ {0} mit einem unbekannten Feldnamen {1} aufgerufen.
#deleteField.sysfield = deleteField() called on object type {0} with a system field name ({1}) that may not be deleted.
deleteField.sysfield = deleteField() wurde für Objekt-Typ {0} mit einem Systemfeld-Namen {1} aufgerufen, der nicht gelöscht werden kann.

#
# fieldInUse
#

#fieldInUse.nofield = Can''t check for non-existent field: {0}
fieldInUse.nofield = Kann nicht auf nicht-existentes Feld prüfen: {0}

#
# getObjectHook
#

#getObjectHook.error = Error, couldn''t create hook in getObjectHook().\n{0}
getObjectHook.error = Fehler: Kann Hook in getObjectHook() nicht erzeugen.\n{0}

#
# getObject
#

#getObject.badtype = Wrong Invid type.
getObject.badtype = Falscher Invid-Typ.

#
# checkSchemaState
#

#checkSchemaState.nolabel = Error, object type {0} has no label field defined.
checkSchemaState.nolabel = Fehler: Für Objekt-Typ {0} ist kein Label-Feld definiert.
#checkSchemaState.notunique = Error, object type {0}''s label field ({1}) is not unique value-constrained.\nYou must set a namespace constraint for this field before committing this schema change.
checkSchemaState.notunique = Fehler: das Label-Feld {1} von Objekt-Typ {0} ist nicht über Namespace eingeschränkt.\nSie müssen einen Namespace für dieses Feld definieren, bevor Sie diese Schemaänderung abspeichern.

#
# clearEditor
#

#clearEditor.clearing = DBObjectBase.clearEditor(): clearing editor for {0}
clearEditor.clearing = DBObjectBase.clearEditor(): lösche Editor für {0}

#
# updateBaseRefs
#

#updateBaseRefs.updating = Updating base reference on {0}
updateBaseRefs.updating = Aktualisiere Basis-Referenz für {0}

#
# setWriteInProgress
#

#setWriteInProgress.doublelock = double write lock in DBObjectBase
setWriteInProgress.doublelock = Doppelte Schreibsperre in DBObjectBase
#setWriteInProgress.doubleunlock = double write unlock in DBObjectBase
setWriteInProgress.doubleunlock = Doppelte Schreibfreigabe in DBObjectBase

#
# addFieldToStart
#

#addFieldToStart.sysfield = Error, attempted to add a system field using addFieldToStart().
addFieldToStart.sysfield = Fehler: Versuch, ein Systemfeld mittels addFieldToStart() hinzuzufügen. 

#
# addFieldAfter
#

#addFieldAfter.sysfield = Error, attempted to add a system field using addFieldAfter().
addFieldAfter.sysfield = Fehler: Versuch, ein Systemfeld mittels addFieldAfter() hinzuzufügen.
#addFieldAfter.noSuchPrevious = Error, couldn''t add field def {0} after field {1}, field {1} was not found in object base.
addFieldAfter.noSuchPrevious = Fehler: kann Feld {0} nicht hinter Feld {1} hinzufügen, da Feld {1} in der Objekt-Basis nicht gefunden wurde.

#
# addFieldToEnd
#

#addFieldToEnd.sysfield = Error, attempted to add a system field using addFieldToEnd().
addFieldToEnd.sysfield = Fehler: Versuch, ein Systemfeld mittels addFieldToEnd() hinzuzufügen.

#
# addSystemField
#

#addSystemField.nonsysfield = Error, attempted to add a non-system field using addSystemField().
addSystemField.nonsysfield = Fehler: Versuch, ein Nichtsystemfeld mittels addSystemField() hinzuzufügen.

