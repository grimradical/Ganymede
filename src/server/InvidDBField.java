/*
   GASH 2

   InvidDBField.java

   The GANYMEDE object storage system.

   Created: 2 July 1996
   Release: $Name:  $
   Version: $Revision: 1.105 $
   Last Mod Date: $Date: 1999/05/26 23:17:29 $
   Module By: Jonathan Abbey, jonabbey@arlut.utexas.edu

   -----------------------------------------------------------------------
	    
   Ganymede Directory Management System
 
   Copyright (C) 1996, 1997, 1998, 1999  The University of Texas at Austin.

   Contact information

   Author Email: ganymede_author@arlut.utexas.edu
   Email mailing list: ganymede@arlut.utexas.edu

   US Mail:

   Computer Science Division
   Applied Research Laboratories
   The University of Texas at Austin
   PO Box 8029, Austin TX 78713-8029

   Telephone: (512) 835-3200

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/

package arlut.csd.ganymede;

import java.io.*;
import java.util.*;
import java.rmi.*;

import arlut.csd.JDialog.*;

/*------------------------------------------------------------------------------
                                                                           class
                                                                    InvidDBField

------------------------------------------------------------------------------*/

/**
 *
 * This class implements one of the most fundamental pieces of logic in the
 * Ganymede server, the object pointer/object binding logic.  Whenever the
 * client calls setValue(), setElement(), addElement(), or deleteElement()
 * on an InvidDBField, the object being pointed to by the Invid being set
 * or cleared will be checked out for editing and the corresponding back
 * pointer will be set or cleared as appropriate.<br><br>
 *
 * In other words, the InvidDBField logic guarantees that all objects
 * references in the server are symmetric.  If one object points to
 * another via an InvidDBField, the target of that pointer will point
 * back, either through a field explicitly specified in the schema, or
 * via the SchemaConstants.BackLinksField, which is guaranteed to be
 * defined in every object in the database.
 *
 * @version $Revision: 1.105 $ %D%
 * @author Jonathan Abbey, jonabbey@arlut.utexas.edu, ARL:UT
 *
 */

public final class InvidDBField extends DBField implements invid_field {

  static final boolean debug = false;

  /**
   *
   * If fixup is true, the InvidDBField.emit() logic will deliberately
   * exclude from the ganymede.db file any ownership links pointing to
   * the supergash owner group, and any ownership links embodied in the
   * supergash owner group.  This is just a hack to transition a ganymede.db
   * file generated by an older version of the code that created explicit
   * supergash ownership links to the (now enforced) world of implicit
   * supergash ownership only.
   *
   */

  static final boolean fixup = false;

  // ---

  /**
   *
   * Receive constructor.  Used to create a InvidDBField from a DBStore/DBJournal
   * DataInput stream.
   *
   */

  InvidDBField(DBObject owner, DataInput in, DBObjectBaseField definition) throws IOException
  {
    super();			// may throw RemoteException

    value = values = null;
    this.owner = owner;
    this.definition = definition;
    receive(in);
  }

  /**
   *
   * No-value constructor.  Allows the construction of a
   * 'non-initialized' field, for use where the DBObjectBase
   * definition indicates that a given field may be present,
   * but for which no value has been stored in the DBStore.
   *
   * Used to provide the client a template for 'creating' this
   * field if so desired.
   *
   */

  InvidDBField(DBObject owner, DBObjectBaseField definition)
  {
    this.owner = owner;
    this.definition = definition;
    
    value = null;

    if (isVector())
      {
	values = new Vector();
      }
    else
      {
	values = null;
      }
  }

  /**
   *
   * Copy constructor.
   *
   */

  public InvidDBField(DBObject owner, InvidDBField field)
  {
    this.owner = owner;
    definition = field.definition;
    
    if (isVector())
      {
	values = (Vector) field.values.clone();
	value = null;
      }
    else
      {
	value = field.value;
	values = null;
      }
  }

  /**
   *
   * Scalar value constructor.
   *
   */

  public InvidDBField(DBObject owner, Invid value, DBObjectBaseField definition)
  {
    if (definition.isArray())
      {
	throw new IllegalArgumentException("scalar value constructor called on vector field " + getName() +
					   " in object " + owner.getLabel());
      }

    this.owner = owner;
    this.definition = null;
    this.value = value;

    values = null;
  }

  /**
   *
   * Vector value constructor.
   *
   */

  public InvidDBField(DBObject owner, Vector values, DBObjectBaseField definition)
  {
    if (!definition.isArray())
      {
	throw new IllegalArgumentException("vector value constructor called on scalar field " + getName() +
					   " in object " + owner.getLabel());
      }

    this.owner = owner;
    this.definition = definition;
    
    if (values == null)
      {
	this.values = new Vector();
      }
    else
      {
	this.values = (Vector) values.clone();
      }

    value = null;
  }
  
  public Object clone()
  {
    return new InvidDBField(owner, this);
  }

  /**
   *
   * This method is used to write the contents of this field to the
   * Ganymede.db file and/or to the Journal file.
   *
   */

  void emit(DataOutput out) throws IOException
  {
    Invid temp;

    /* -- */

    if (isVector())
      {
	// this is a hack.. this is for creating a db file with all the supergash
	// ownership links scoured.

	if (fixup)
	  {
	    Invid superOwner = new Invid((short)0,(short)1);

	    // we want to omit any ownership links to the
	    // supergash owner group

	    if (getID() == 0 && !owner.objectBase.isEmbedded())
	      {
		int size = values.size();
		int count = 0;

		if (values.contains(superOwner))
		  {
		    System.err.println("InvidDBField.emit(fixup): omitting supergash owner link: " + 
				       owner.getTypeName() + ": " + owner.getLabel() + " " + getName());
		  }

		for (int i = 0; i < values.size(); i++)
		  {
		    temp = (Invid) values.elementAt(i);

		    if (temp.equals(superOwner))
		      {
			size--;
		      }
		  }

		System.err.println("InvidDBField.emit(): values.size() == " + values.size() +
				   ", size == " + size);

		out.writeShort(size);

		for (int i = 0; i < values.size(); i++)
		  {
		    temp = (Invid) values.elementAt(i);

		    if (!temp.equals(superOwner))
		      {
			System.err.print("*");

			out.writeShort(temp.getType());
			out.writeInt(temp.getNum());
			count++;
		      }
		  }

		if (count != size)
		  {
		    System.err.println("%%%%%%%%% count mismatch");
		  }
	      }
	    else if (getID() == SchemaConstants.OwnerObjectsOwned && owner.getInvid().equals(superOwner))
	      {
		// we want to omit any objects owned by Supergash
		out.writeShort(0);

		 System.err.println("InvidDBField.emit(fixup): omitting " + values.size() + " objects owned by supergash");
	      }
	    else
	      {
		out.writeShort(values.size());
		
		for (int i = 0; i < values.size(); i++)
		  {
		    temp = (Invid) values.elementAt(i);
		    out.writeShort(temp.getType());
		    out.writeInt(temp.getNum());
		  }
	      }
	  }
	else
	  {
	    out.writeShort(values.size());

	    for (int i = 0; i < values.size(); i++)
	      {
		temp = (Invid) values.elementAt(i);
		out.writeShort(temp.getType());
		out.writeInt(temp.getNum());
	      }
	  }
      }
    else
      {
	temp = (Invid) value;

	try
	  {
	    out.writeShort(temp.getType());
	    out.writeInt(temp.getNum());
	  }
	catch (NullPointerException ex)
	  {
	    System.err.println(owner.getLabel() + ":" + getName() + ": void value in emit");

	    if (temp == null)
	      {
		System.err.println(owner.getLabel() + ":" + getName() + ": field value itself is null");
	      }

	    throw ex;
	  }
      }
  }

  /**
   *
   * This method is used to read the contents of this field from the
   * Ganymede.db file and/or from the Journal file.
   *
   */

  void receive(DataInput in) throws IOException
  {
    Invid temp;
    int count;

    /* -- */

    if (isVector())
      {
	//	System.err.println("Reading InvidDBField: " + getName());

	count = in.readShort();

	//	System.err.println(count + " values");

	if (count > 0)
	  {
	    values = new Vector(count);

	    for (int i = 0; i < count; i++)
	      {
		temp = new Invid(in.readShort(), in.readInt());
		values.addElement(temp);
	      }
	  }
	else
	  {
	    values = new Vector();
	  }
      }
    else
      {
	value = new Invid(in.readShort(), in.readInt());
      }
  }

  // ****
  //
  // type-specific accessor methods
  //
  // ****

  public Invid value()
  {
    if (isVector())
      {
	throw new IllegalArgumentException("scalar accessor called on vector " + getName() +
					   " in object " + owner.getLabel());
      }

    return (Invid) value;
  }

  public Invid value(int index)
  {
    if (!isVector())
      {
	throw new IllegalArgumentException("vector accessor called on scalar " + getName() +
					   " in object " + owner.getLabel());
      }

    return (Invid) values.elementAt(index);
  }

  /**
   *
   * This method returns a text encoded value for this InvidDBField
   * without checking permissions.<br><br>
   *
   * This method avoids checking permissions because it is used on
   * the server side only and because it is involved in the getLabel()
   * logic for DBObject, which is invoked from GanymedeSession.getPerm().<br><br>
   *
   * If this method checked permissions and the getPerm() method
   * failed for some reason and tried to report the failure using
   * object.getLabel(), as it does at present, the server could get
   * into an infinite loop.
   *
   */

  public synchronized String getValueString()
  {
    GanymedeSession gsession = null;

    /* -- */

    // where will we go to look up the label for our target(s)?

    try
      {
	if (owner.editset != null)
	  {
	    gsession = owner.editset.getSession().getGSession();
	  }
      }
    catch (NullPointerException ex)
      {
      }

    if (gsession == null)
      {
	gsession = Ganymede.internalSession;
      }

    // now do the work

    if (!isVector())
      {
	if (value == null)
	  {
	    return "null";
	  }

	Invid localInvid = (Invid) this.value();

	// XXX note: we don't use our owner's lookupLabel() method
	// for scalar invid values.. 

	return getRemoteLabel(gsession, localInvid);
      }
    else
      {
	int size = size();

	if (size == 0)
	  {
	    return "";
	  }

	String entries[] = new String[size];
	Invid tmp;

	for (int i = 0; i < size; i++)
	  {
	    tmp = this.value(i);

	    entries[i] = getRemoteLabel(gsession, tmp);
	  }

	new arlut.csd.Util.QuickSort(entries,
				     new arlut.csd.Util.Compare()
				     {
				       public int compare(Object a, Object b)
					 {
					   String aS, bS;
					   
					   aS = (String) a;
					   bS = (String) b;
					   
					   return aS.compareTo(bS);
					 }
				     }
				     ).sort();

	StringBuffer result = new StringBuffer();

	for (int i = 0; i < entries.length; i++)
	  {
	    if (i > 0)
	      {
		result.append(", ");
	      }

	    result.append(entries[i]);
	  }

	return result.toString();
      }
  }

  /**
   *
   * This method returns the label of an object referenced by an
   * invid held in this field.  If the object label returned is currently
   * null, we'll check to see if the remote object is currently being
   * edited by this session.  If it is, we'll try to get the label from
   * the state of that object as it existed at the start of the
   * current transaction.  This is to allow us to do proper logging
   * of the values deleted from this field in the case of the string
   * generated by DBEditObject.diff() during transaction logging.
   *
   */

  private String getRemoteLabel(GanymedeSession gsession, Invid invid)
  {
    if (gsession != null)
      {
	/*
	 * okay.. if we are finding the name of the referenced field in
	 * the DBEditSet logging context, our reference might have already
	 * had its fields cleared out.. we want to be able to get access
	 * to the label it had for the purpose of logging this transaction..
	 *
	 * the DBEditSet commit() logic uses DBEditObject.diff(), which
	 * will call us to get the original value of a invid field (perhaps
	 * before the current version of this field was cleared.. we need
	 * to also be able to present the name of the remote object before
	 * it was cleared..
	 */

	DBObject objectRef = gsession.session.viewDBObject(invid);

	if (objectRef != null && (objectRef instanceof DBEditObject) &&
	    ((DBEditObject) objectRef).getStatus() == ObjectStatus.DELETING)
	  {
	    objectRef = ((DBEditObject) objectRef).original;
	  }

	return objectRef.getLabel();
      }
    else
      {
	return this.value().toString();
      }
  }

  /**
   *
   * OK, this is a bit vague.. getEncodingString() is used by the new
   * dump system to allow all fields to be properly sorted in the table..
   * a real reversible encoding of an invid field would *not* be the
   * getValueString() results, but getValueString() is what we want in
   * the dump result table, so we'll do that here for now.
   *
   */

  public String getEncodingString()
  {
    return getValueString();
  }

  /**
   *
   * Returns a String representing the change in value between this
   * field and orig.  This String is intended for logging and email,
   * not for any sort of programmatic activity.  The format of the
   * generated string is not defined, but is intended to be suitable
   * for inclusion in a log entry and in an email message.
   *
   * If there is no change in the field, null will be returned.
   * 
   */

  public synchronized String getDiffString(DBField orig)
  {
    StringBuffer result = new StringBuffer();
    InvidDBField origI;
    DBObject object;
    GanymedeSession gsession = null;

    /* -- */

    if (!(orig instanceof InvidDBField))
      {
	throw new IllegalArgumentException("bad field comparison " + getName());
      }

    if (debug)
      {
	System.err.println("Entering InvidDBField getDiffString()");
      }

    if (orig == this)
      {
	return "";
      }

    origI = (InvidDBField) orig;

    try
      {
	if (owner.editset != null)
	  {
	    gsession = owner.editset.getSession().getGSession();
	  }
      }
    catch (NullPointerException ex)
      {
      }
    
    if (gsession == null)
      {
	gsession = Ganymede.internalSession;
      }

    if (isVector())
      {
	Vector 
	  added = new Vector(),
	  deleted = new Vector();

	Enumeration enum;

	Object 
	  element = null;

	Invid
	  elementA = null,
	  elementB = null;

	boolean found = false;

	/* -- */

	if (debug)
	  {
	    System.err.println("vector diff.. searching for deleted items");
	  }

	// find elements in the orig field that aren't in our present field

	Hashtable currentElements = new Hashtable();

	for (int i = 0; !found && i < values.size(); i++)
	  {
	    if (debug)
	      {
		System.err.print(",");
	      }

	    element = values.elementAt(i);

	    currentElements.put(element, element);
	  }

	enum = origI.values.elements();

	while (enum.hasMoreElements())
	  {
	    if (debug)
	      {
		System.err.print("x");
	      }

	    element = enum.nextElement();

	    if (currentElements.get(element) == null)
	      {
		deleted.addElement(element);
	      }
	  }

	// find elements in our present field that aren't in the orig field

	if (debug)
	  {
	    System.err.println("vector diff.. searching for added items");
	  }

	Hashtable origElements = new Hashtable();

	for (int i = 0; !found && i < origI.values.size(); i++)
	  {
	    if (debug)
	      {
		System.err.print(",");
	      }

	    element = origI.values.elementAt(i);
	    
	    origElements.put(element, element);
	  }

	enum = values.elements();

	while (enum.hasMoreElements())
	  {
	    if (debug)
	      {
		System.err.print("x");
	      }

	    element = enum.nextElement();

	    if (origElements.get(element) == null)
	      {
		added.addElement(element);
	      }
	  }

	// were there any changes at all?

	if (deleted.size() == 0 && added.size() == 0)
	  {
	    return null;
	  }
	else
	  {
	    if (deleted.size() != 0)
	      {
		if (debug)
		  {
		    System.err.print("Working out deleted items");
		  }

		result.append("\tDeleted: ");
	    
		for (int i = 0; i < deleted.size(); i++)
		  {
		    elementA = (Invid) deleted.elementAt(i);

		    if (i > 0)
		      {
			result.append(", ");
		      }

		    result.append(getRemoteLabel(gsession, elementA));
		  }

		result.append("\n");
	      }

	    if (added.size() != 0)
	      {
		if (debug)
		  {
		    System.err.print("Working out added items");
		  }

		result.append("\tAdded: ");
	    
		for (int i = 0; i < added.size(); i++)
		  {
		    elementA = (Invid) added.elementAt(i);

		    if (i > 0)
		      {
			result.append(", ");
		      }

		    result.append(getRemoteLabel(gsession, elementA));
		  }

		result.append("\n");
	      }

	    return result.toString();
	  }
      }
    else
      {
	if (debug)
	  {
	    System.err.println("InvidDBField: scalar getDiffString() comparison");
	  }

	if (origI.value().equals(this.value()))
	  {
	    return null;
	  }
	else
	  {
	    result.append("\tOld: ");

	    result.append(getRemoteLabel(gsession, origI.value()));

	    result.append("\n\tNew: ");

	    result.append(getRemoteLabel(gsession, this.value()));

	    result.append("\n");
	
	    return result.toString();
	  }
      }
  }

  // ****
  //
  // methods for maintaining invid symmetry
  //
  // ****

  /**
   * <p>This method is used to link the remote invid to this checked-out invid
   * in accordance with this field's defined symmetry constraints.</p>
   *
   * <p>This method will extract the objects referenced by the old and new
   * remote parameters, and will cause the appropriate invid dbfields in
   * them to be updated to reflect the change in link status.  If either
   * operation can not be completed, bind will return the system to its
   * pre-bind status and return false.  One or both of the specified
   * remote objects may remain checked out in the current editset until
   * the transaction is committed or released.</p>
   *
   * <p>It is an error for newRemote to be null;  if you wish to undo an
   * existing binding, use the unbind() method call.  oldRemote may
   * be null if this currently holds no value, or if this is a vector
   * field and newRemote is being added.</p>
   *
   * <p>This method should only be called from synchronized methods within
   * InvidDBField.</p>
   *
   * <p><b>This method is private, and is not to be called by any code outside
   * of this class.</b></p>
   *
   * @param oldRemote the old invid to be replaced
   * @param newRemote the new invid to be linked
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   * @return null on success, or a ReturnVal with an error dialog encoded on failure
   *
   * @see arlut.csd.ganymede.InvidDBField#unbind(arlut.csd.ganymede.Invid, boolean)
   */

  private final ReturnVal bind(Invid oldRemote, Invid newRemote, boolean local)
  {
    short targetField;

    DBEditObject 
      eObj = null,
      oldRef = null,
      newRef = null;

    InvidDBField 
      oldRefField = null,
      newRefField = null;

    DBSession
      session = null;

    boolean 
      anonymous = false,
      anonymous2 = false;

    ReturnVal 
      retVal = null,
      newRetVal;

    DBObject remobj = null;

    /* -- */

    if (newRemote == null)
      {
	throw new IllegalArgumentException("null newRemote " + getName() + " in object " + owner.getLabel());
      }

    if (!isEditable(local))
      {
	throw new IllegalArgumentException("not an editable invid field: " + getName() + 
					   " in object " + owner.getLabel());
      }

    eObj = (DBEditObject) this.owner;
    session = eObj.getSession();

    // find out whether there is an explicit back-link field

    if (getFieldDef().isSymmetric())
      {
	// find out what field in remote we might need to update

	targetField = getFieldDef().getTargetField();
      }
    else
      {
	targetField = SchemaConstants.BackLinksField;
      }

    if ((oldRemote != null) && oldRemote.equals(newRemote))
      {
	return null;		// success
      }

    // check out the old object and the new object
    // remove the reference from the old object
    // add the reference to the new object

    if (oldRemote != null)
      {
	// check to see if we have permission to anonymously unlink
	// this field from the target field, else go through the
	// GanymedeSession layer to have our permissions checked.

	// note that if the GanymedeSession layer has already checked out the
	// object, session.editDBObject() will return a reference to that
	// version, and we'll lose our security bypass.. for that reason,
	// we also use the anonymous variable to instruct dissolve to disregard
	// write permissions if we have gotten the anonymous OK

	remobj = session.viewDBObject(oldRemote);

	if (remobj == null)
	  {
	    return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't find old reference",
					      "Your operation could not succeed because field " + getName() +
					      " was linked to a remote reference " + oldRef.toString() + 
					      " that could not be found for unlinking.\n\n" +
					      "This is a serious logic error in the server.");
	  }

	// see if we are allowed to unlink the remote object without
	// having permission to edit it generally.

	anonymous = session.getObjectHook(oldRemote).anonymousUnlinkOK(remobj,
								       targetField, 
								       session.getGSession());

	// if we're already editing it, just go with that.

	if (remobj instanceof DBEditObject)
	  {
	    oldRef = (DBEditObject) remobj;
	  }
	else
	  {
	    if (anonymous || session.getGSession().getPerm(remobj).isEditable())
	      {
		oldRef = (DBEditObject) session.editDBObject(oldRemote);
	      }
	    else
	      {
		return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't unlink old reference",
						  "Your operation could not succeed because you don't " +
						  "have permission to dissolve the link to the old object " +
						  "held in field " + getName() + " in object " + owner.getLabel());
	      }
	  }

	if (oldRef == null)
	  {
	    return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't unlink old reference",
					      "Your operation could not succeed because field " + getName() +
					      " was linked to a remote reference " + oldRef.toString() + 
					      " that could not be found for unlinking.\n\n" +
					      "This is a serious logic error in the server.");
	  }

	try
	  {
	    oldRefField = (InvidDBField) oldRef.getField(targetField);
	  }
	catch (ClassCastException ex)
	  {
	    try
	      {
		return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't unlink old reference",
						  "Your operation could not succeed due to an error in the " +
						  "server's schema.  Target field " + 
						  oldRef.getField(targetField).getName() +
						  " in object " + oldRef.getLabel() +
						  " is not an invid field.");
	      }
	    catch (RemoteException rx)
	      {
		return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't unlink old reference",
						  "Your operation could not succeed due to an error in the " +
						  "server's schema.  Target field " + targetField +
						  " in object " + oldRef.getLabel() +
						  " is not an invid field.");
	      }
	  }
	
	if (oldRefField == null)
	  {
	    // editDBObject() will create undefined fields for all fields defined
	    // in the DBObjectBase, so if we got a null result we have a schema
	    // corruption problem.

	    String tempString = "InvidDBField.bind: old target field not defined <" + owner.getLabel() +
	      ":" + getName() + "> in <" + oldRef.getLabel() + ":" + targetField + ">";
	    
	    setLastError(tempString);

	    return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't unlink old reference",
					      "Your operation could not succeed due to a possible inconsistency in the " +
					      "server database.  Target field number " + targetField +
					      " in object " + oldRef.getLabel() +
					      " does not exist, or you do not have permission to access " +
					      "this field.");
	  }
      }

    // check to see if we have permission to anonymously link
    // this field to the target field, else go through the
    // GanymedeSession layer to have our permissions checked.

    // note that if the GanymedeSession layer has already checked out the
    // object, session.editDBObject() will return a reference to that
    // version, and we'll lose our security bypass.. for that reason,
    // we also use the anonymous2 variable to instruct establish to disregard
    // write permissions if we have gotten the anonymous OK

    remobj = session.viewDBObject(newRemote);
    
    if (remobj == null)
      {
	return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't find new reference",
					  "Your operation could not succeed because field " + getName() +
					  " cannot link to non-existent invid " + newRemote.toString() + 
					  ".\n\nThis is a serious logic error in the server.");
      }

    // see if we are allowed to link the remote object without having
    // permission to edit it generally.
    
    anonymous = session.getObjectHook(newRemote).anonymousLinkOK(remobj,
								 targetField, 
								 session.getGSession());
    // if we're already editing it, just go with that.

    if (remobj instanceof DBEditObject)
      {
	newRef = (DBEditObject) remobj;
      }
    else
      {
	if (anonymous || session.getGSession().getPerm(remobj).isEditable())
	  {
	    newRef = (DBEditObject) session.editDBObject(newRemote);
	  }
      }
    
    if (newRef == null)
      {
	return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't link to new reference",
					  "Your operation could not succeed because field " + getName() +
					  " could not be linked to " + newRemote.toString() + 
					  ".  This could be due to a lack of permissions.");
      }

    try
      {
	newRefField = (InvidDBField) newRef.getField(targetField);
      }
    catch (ClassCastException ex)
      {
	try
	  {
	    return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't link to new reference",
					      "Your operation could not succeed due to an error in the " +
					      "server's schema.  Target field " + 
					      newRef.getField(targetField).getName() +
					      " in object " + newRef.getLabel() +
					      " is not an invid field.");
	  }
	catch (RemoteException rx)
	  {
	    return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't link to new reference",
					      "Your operation could not succeed due to an error in the " +
					      "server's schema.  Target field " + 
					      targetField +
					      " in object " + newRef.getLabel() +
					      " is not an invid field.");
	  }
      }
    
    if (newRefField == null)
      {
	// editDBObject() will create undefined fields for all fields defined
	// in the DBObjectBase, so if we got a null result we have a schema
	// corruption problem.
	
	String tempString = "InvidDBField.bind: target field not defined <" + owner.getLabel() +
	  ":" + getName() + "> in <" + newRef.getLabel() + ":" + targetField + ">";

	setLastError(tempString);

	return Ganymede.createErrorDialog("InvidDBField.bind(): Couldn't link new reference",
					  "Your operation could not succeed due to a possible inconsistency in the " +
					  "server database.  Target field number " + targetField +
					  " in object " + newRef.getLabel() +
					  " does not exist, or you do not have permission to access " +
					  "this field.");
      }

    // okay, at this point we should have oldRefField pointing to the
    // old target field, and newRefField pointing to the new target field.

    // Do our job.

    if (oldRefField != null)
      {
        retVal = oldRefField.dissolve(owner.getInvid(), (anonymous||local));

 	if (retVal != null && !retVal.didSucceed())
	  {
	    return retVal;
	  }
      }
    
    newRetVal = newRefField.establish(owner.getInvid(), (anonymous2||local));

    if (newRetVal != null && !newRetVal.didSucceed())
      {
	// oops!  try to undo what we did.. this probably isn't critical
	// because something above us will do a rollback, but it's polite.

	if (oldRefField != null)
	  {
	    oldRefField.establish(owner.getInvid(), (anonymous||local)); // hope this works
	  }
	
	return newRetVal;
      }

    if (retVal != null)
      {
	retVal.unionRescan(newRetVal);
      }
    else
      {
	retVal = newRetVal;
      }

    // tell the client that it needs to rescan both the old and new
    // remote ends of this binding

    newRetVal = new ReturnVal(true, true);

    if (oldRemote != null)
      {
	newRetVal.addRescanField(oldRemote, targetField);
      }

    newRetVal.addRescanField(newRemote, targetField);
    newRetVal.unionRescan(retVal);

    return newRetVal;		// success
  }

  /**
   * <p>This method is used to unlink this field from the specified remote
   * invid in accordance with this field's defined symmetry constraints.</p>
   *
   * <p><b>This method is private, and is not to be called by any code outside
   * of this class.</b></p>
   *
   * @param remote An invid for an object to be checked out and unlinked
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   * @return null on success, or a ReturnVal with an error dialog encoded on failure
   */

  private final ReturnVal unbind(Invid remote, boolean local)
  {
    short targetField;

    DBEditObject 
      eObj = null,
      oldRef = null;

    DBObject
      remobj;

    InvidDBField 
      oldRefField = null;

    DBSession
      session = null;

    ReturnVal
      retVal = null,
      newRetVal;

    boolean anonymous;

    /* -- */

    if (remote == null)
      {
	return null;

	// throw new IllegalArgumentException("null remote: " + getName() + " in object " + owner.getLabel());
      }

    if (!isEditable(local))
      {
	throw new IllegalArgumentException("not an editable invid field: " + getName() +
					   " in object " + owner.getLabel());
      }

    eObj = (DBEditObject) this.owner;
    session = eObj.getSession();

    // if we are unbinding a backlinks field, we want to use
    // unbindAll() to clear any fields that are using the backlinks
    // pool.

    if (this.getID() == SchemaConstants.BackLinksField)
      {
	// our owner will set clearingBackLinks if it is doing a mass
	// deletion of all links in the BackLinksField.. in this case,
	// we don't need or want to wrap our unbindAll() call with our
	// own checkpoint/rollback pair.

	if (eObj.clearingBackLinks)
	  {
	    retVal = unbindAll(remote, local);
	  }
	else
	  {
	    String checkKey = "unbindAll()" + new Date();
	
	    session.checkpoint(checkKey);
	    
	    retVal = unbindAll(remote, local);
	    
	    if (retVal == null || retVal.didSucceed())
	      {
		session.popCheckpoint(checkKey);
	      }
	    else
	      {
		session.rollback(checkKey);
	      }
	  }

	return retVal;
      }

    // find out whether there is an explicit back-link field

    if (getFieldDef().isSymmetric())
      {
	// find out what field in remote we might need to update

	targetField = getFieldDef().getTargetField();
      }
    else
      {
	targetField = SchemaConstants.BackLinksField;
      }

    // check to see if we have permission to anonymously unlink
    // this field from the target field, else go through the
    // GanymedeSession layer to have our permissions checked.

    // note that if the GanymedeSession layer has already checked out the
    // object, session.editDBObject() will return a reference to that
    // version, and we'll lose our security bypass.. for that reason,
    // we also use the anonymous variable to instruct dissolve to disregard
    // write permissions if we have gotten the anonymous OK

    remobj = session.viewDBObject(remote);
	
    if (remobj == null)
      {
	return Ganymede.createErrorDialog("InvidDBField.unbind(): Couldn't find old reference",
					  "Your operation could not succeed because field " + getName() +
					  " was linked to a remote reference " + remote.toString() + 
					  " that could not be found for unlinking.\n\n" +
					  "This is a serious logic error in the server.");
      }

    // see if we are allowed to unlink the remote object without
    // having permission to edit it generally.

    anonymous = session.getObjectHook(remote).anonymousUnlinkOK(remobj,
								targetField, 
								session.getGSession());

    // if we're already editing it, just go with that.

    if (remobj instanceof DBEditObject)
      {
	oldRef = (DBEditObject) remobj;
      }
    else
      {
	if (anonymous || session.getGSession().getPerm(remobj).isEditable())
	  {
	    oldRef = (DBEditObject) session.editDBObject(remote);
	  }
      }

    if (oldRef == null)
      {
	// it's there, but we can't unlink it
	    
	return Ganymede.createErrorDialog("InvidDBField.unbind(): Couldn't unlink old reference",
					  "We couldn't unlink field " + getName() +
					  " in object " + getOwner().getLabel() +
					  " from field " + targetField + " in object " +
					  getRemoteLabel(session.getGSession(), remote) +
					  " due to a permissions problem.");
      }

    try
      {
	oldRefField = (InvidDBField) oldRef.getField(targetField);
      }
    catch (ClassCastException ex)
      {
	try
	  {
	    return Ganymede.createErrorDialog("InvidDBField.unbind(): Couldn't unlink old reference",
					      "Your operation could not succeed due to an error in the " +
					      "server's schema.  Target field " + oldRef.getField(targetField).getName() +
					      " in object " + oldRef.getLabel() +
					      " is not an invid field.");
	  }
	catch (RemoteException rx)
	  {
	    return Ganymede.createErrorDialog("InvidDBField.unbind(): Couldn't unlink old reference",
					      "Your operation could not succeed due to an error in the " +
					      "server's schema.  Target field " + targetField +
					      " in object " + oldRef.getLabel() +
					      " is not an invid field.");
	  }
      }

    if (oldRefField == null)
      {
	// editDBObject() will create undefined fields for all fields defined
	// in the DBObjectBase, so if we got a null result we have a schema
	// corruption problem.

	return Ganymede.createErrorDialog("InvidDBField.unbind(): Couldn't unlink old reference",
					  "Your operation could not succeed due to a possible inconsistency in the " +
					  "server database.  Target field number " + targetField +
					  " in object " + oldRef.getLabel() +
					  " does not exist, or you do not have permission to access " +
					  "this field.");
      }

    try
      {
	// note that we only want to remove one instance of the invid
	// pointing back to us.. we may have multiple fields on the
	// this object pointing to the remote, and we want to only
	// clear one back pointer at a time.

	retVal = oldRefField.dissolve(owner.getInvid(), anonymous||local);

	if (retVal != null && !retVal.didSucceed())
	  {
	    return retVal;
	  }
      }
    catch (IllegalArgumentException ex)
      {
	System.err.println("hm, couldn't dissolve a reference in " + getName());

	if (anonymous)
	  {
	    System.err.println("Did do an anonymous edit on target");
	  }
	else
	  {
	    System.err.println("Didn't do an anonymous edit on target");
	  }

	throw (IllegalArgumentException) ex;
      }
	

    // tell the client that it needs to rescan the old remote end of this binding

    newRetVal = new ReturnVal(true, true);
    newRetVal.addRescanField(remote, targetField);

    newRetVal.unionRescan(retVal);

    return newRetVal;		// success
  }

  /**
   *
   * This method is used to unlink a backlink field from the specified remote
   * invid across all Invid fields defined in the remote object corresponding
   * to remote.
   *
   * <b>This method is private, and is not to be called by any code outside
   * of this class.</b>
   *
   * @param remote An invid for an object to be checked out and unlinked
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   * @return null on success, or a ReturnVal with an error dialog encoded on failure
   *
   */

  private final ReturnVal unbindAll(Invid remote, boolean local)
  {
    short targetField;

    DBEditObject 
      eObj = null,
      oldRef = null;

    DBObject
      remobj;

    InvidDBField 
      oldRefField = null;

    DBSession
      session = null;

    ReturnVal
      retVal = null,
      newRetVal;

    Vector
      fieldsToUnbind = new Vector();

    // debug vars

    boolean skipPermsOK = true;
    boolean anon = false;

    /* -- */

    if (this.getID() != SchemaConstants.BackLinksField)
      {
	throw new RuntimeException("Error, InvidDBField.unbindAll() is only for the back links field.");
      }

    if (remote == null)
      {
	return null;

	// throw new IllegalArgumentException("null remote: " + getName() + " in object " + owner.getLabel());
      }

    if (!isEditable(local))
      {
	throw new IllegalArgumentException("not an editable invid field: " + getName() +
					   " in object " + owner.getLabel());
      }

    eObj = (DBEditObject) this.owner;
    session = eObj.getSession();

    // check to see if we have permission to anonymously unlink
    // this field from the target field, else go through the
    // GanymedeSession layer to have our permissions checked.

    // note that if the GanymedeSession layer has already checked out the
    // object, session.editDBObject() will return a reference to that
    // version, and we'll lose our security bypass.. for that reason,
    // we also use the anon variable to instruct dissolve to disregard
    // write permissions if we have gotten the anonymous OK

    remobj = session.viewDBObject(remote);
	
    if (remobj == null)
      {
	return Ganymede.createErrorDialog("InvidDBField.unbindAll(): Couldn't find old reference",
					  "Your operation could not succeed because field " + getName() +
					  " was linked to a remote reference " + remote.toString() + 
					  " that could not be found for unlinking.\n\n" +
					  "This is a serious logic error in the server.");
      }

    // loop over the invid fields in the target, get a list of fields we need to unlink.

    Invid myInvid = eObj.getInvid();
    Enumeration fieldEnum = remobj.fields.elements();

    while (fieldEnum.hasMoreElements())
      {
	DBField tmpField = (DBField) fieldEnum.nextElement();

	if (!(tmpField instanceof InvidDBField))
	  {
	    continue;
	  }

	// If the invid field we're checking out doesn't reference
	// us, don't bother with it.

	if (tmpField.isVector())
	  {
	    if (!tmpField.containsElementLocal(myInvid))
	      {
		continue;
	      }
	  }
	else
	  {
	    Invid tempInvid = (Invid) tmpField.getValueLocal();

	    if (tempInvid == null || !tempInvid.equals(myInvid))
	      {
		continue;
	      }
	  }

	// if the field is symmetric and doesn't point to us, we won't
	// try to unlink it here.

	if (tmpField.getFieldDef().isSymmetric())
	  {
	    if (tmpField.getFieldDef().getTargetField() != this.getID())
	      {
		continue;
	      }
	  }

	// ok, we know we need to do the unbinding for this field.

	fieldsToUnbind.addElement(new Short(tmpField.getID()));

	if (!session.getObjectHook(remote).anonymousUnlinkOK(remobj, tmpField.getID(), session.getGSession()))
	  {
	    skipPermsOK = false;
	  }
      }

    if (remobj instanceof DBEditObject)
      {
	oldRef = (DBEditObject) remobj;
      }
    else
      {
	if (skipPermsOK || session.getGSession().getPerm(remobj).isEditable())
	  {
	    oldRef = (DBEditObject) session.editDBObject(remote);
	  }
      }

    if (oldRef == null)
      {
	// it's there, but we can't unlink it
		
	return Ganymede.createErrorDialog("InvidDBField.unbindAll(): Couldn't unlink old reference",
					  "We couldn't unlink the backlinks field in object " +
					  getOwner().getLabel() + " from one or more fields in object " +
					  getRemoteLabel(session.getGSession(), remote) +
					  " due to a permissions problem.");
      }

    // initialize a ReturnVal to remember our rescan information.

    newRetVal = new ReturnVal(true, true);
    
    for (int i = 0; i < fieldsToUnbind.size(); i++)
      {
	Short remote_fieldid = (Short) fieldsToUnbind.elementAt(i);
	targetField = remote_fieldid.shortValue();

	newRetVal.addRescanField(remote, targetField);

	// are we allowed to ignore permissions on this field?
    
	anon = session.getObjectHook(remote).anonymousUnlinkOK(remobj, 
							       targetField, 
							       session.getGSession());
	try
	  {
	    oldRefField = (InvidDBField) oldRef.getField(targetField);
	  }
	catch (ClassCastException ex)
	  {
	    try
	      {
		return Ganymede.createErrorDialog("InvidDBField.unbindAll(): Couldn't unlink old reference",
						  "Your operation could not succeed due to an error in the " +
						  "server's schema.  Target field " + 
						  oldRef.getField(targetField).getName() +
						  " in object " + oldRef.getLabel() +
						  " is not an invid field.");
	      }
	    catch (RemoteException rx)
	      {
		return Ganymede.createErrorDialog("InvidDBField.unbindAll(): Couldn't unlink old reference",
						  "Your operation could not succeed due to an error in the " +
						  "server's schema.  Target field " + targetField +
						  " in object " + oldRef.getLabel() +
						  " is not an invid field.");
	      }
	  }

	if (oldRefField == null)
	  {
	    // editDBObject() will create undefined fields for all fields defined
	    // in the DBObjectBase, so if we got a null result we have a schema
	    // corruption problem.

	    return Ganymede.createErrorDialog("InvidDBField.unbindAll(): Couldn't unlink old reference",
					      "Your operation could not succeed due to a possible inconsistency in the " +
					      "server database.  Target field number " + targetField +
					      " in object " + oldRef.getLabel() +
					      " does not exist, or you do not have permission to access " +
					      "this field.");
	  }

	try
	  {
	    // note that we only want to remove one instance of the invid
	    // pointing back to us.. we may have multiple fields on the
	    // this object pointing to the remote, and we want to only
	    // clear one back pointer at a time.

	    retVal = oldRefField.dissolve(owner.getInvid(), anon||local);

	    if (retVal != null && !retVal.didSucceed())
	      {
		return retVal;
	      }
	  }
	catch (IllegalArgumentException ex)
	  {
	    System.err.println("hm, couldn't dissolve a reference in " + getName());

	    if (anon)
	      {
		System.err.println("Did do an anonymous edit on target");
	      }
	    else
	      {
		System.err.println("Didn't do an anonymous edit on target");
	      }

	    throw (IllegalArgumentException) ex;
	  }
      }
    
    // tell the client that it needs to rescan the old remote ends of this binding

    newRetVal.unionRescan(retVal);

    return newRetVal;		// success
  }

  /**
   *
   * This method is used to effect the remote side of an unbind operation.<br><br>
   *
   * An InvidDBField being manipulated with the standard editing accessors
   * (setValue, addElement, deleteElement, setElement) will call this method
   * on another InvidDBField in order to unlink a pair of symmetrically bound
   * InvidDBFields.<br><br>
   *
   * This method will return false if the unbinding could not be performed for
   * some reason.<br><br>
   *
   * <b>This method is private, and is not to be called by any code outside
   * of this class.</b>
   *
   * @param oldInvid The invid to be unlinked from this field.  If this
   * field is not linked to the invid specified, nothing will happen.
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   */

  private synchronized final ReturnVal dissolve(Invid oldInvid, boolean local)
  {
    int 
      index = -1;

    Invid tmp;

    DBEditObject eObj;

    /* -- */

    // We wouldn't be called here unless this Object and InvidDBField
    // were editable.. bind/unbind check things out for us.

    eObj = (DBEditObject) owner;

    if (isVector())
      {
	// note that we only want to remove one instance of the invid pointing
	// to us.. we may have multiple fields on the remote object pointing
	// to us, and we want to only clear one back pointer at a time.

	for (int i = 0; i < values.size(); i++)
	  {
	    tmp = (Invid) values.elementAt(i);

	    if (tmp.equals(oldInvid))
	      {
		index = i;
		break;
	      }
	  }

	if (index == -1)
	  {
	    Ganymede.debug("warning: dissolve for " + 
			   owner.getLabel() + ":" + getName() + 
			   " called with an unbound invid (vector): " + 
			   oldInvid.toString());

	    return null;	// we're already dissolved, effectively
	  }

	ReturnVal retVal = eObj.finalizeDeleteElement(this, index);

	if (retVal == null || retVal.didSucceed())
	  {
	    values.removeElementAt(index);

	    return retVal;
	  }
	else
	  {
	    setLastError("InvidDBField remote dissolve: couldn't finalizeDeleteElement");

	    if (retVal.getDialog() != null)
	      {
		return Ganymede.createErrorDialog("InvidDBField.dissolve(): couldn't finalizeDeleteElement",
						  "The custom plug-in class for object " + eObj.getLabel() +
						  "refused to allow us to clear out all the references in field " + 
						  getName() + ":\n\n" + retVal.getDialog().getText());
	      }
	    else
	      {
		return Ganymede.createErrorDialog("InvidDBField.dissolve(): couldn't finalizeDeleteElement",
						  "The custom plug-in class for object " + eObj.getLabel() +
						  "refused to allow us to clear out all the references in field " + 
						  getName());
	      }
	  }
      }
    else
      {
	tmp = (Invid) value;

	if (!tmp.equals(oldInvid))
	  {
	    throw new RuntimeException("dissolve called with an unbound invid (scalar)");
	  }

	ReturnVal retVal = eObj.finalizeSetValue(this, null);

	if (retVal == null || retVal.didSucceed())
	  {
	    value = null;

	    return retVal;
	  }
	else
	  {
	    setLastError("InvidDBField remote dissolve: couldn't finalizeSetValue");

	    if (retVal.getDialog() != null)
	      {
		return Ganymede.createErrorDialog("InvidDBField.dissolve(): couldn't finalizeSetValue",
						  "The custom plug-in class for object " + 
						  eObj.getLabel() +
						  "refused to allow us to clear out the reference in field " + 
						  getName() + ":\n\n" + retVal.getDialog().getText());
	      }
	    else
	      {
		return Ganymede.createErrorDialog("InvidDBField.dissolve(): couldn't finalizeSetValue",
						  "The custom plug-in class for object " + 
						  eObj.getLabel() +
						  "refused to allow us to clear out the reference in field " + 
						  getName());
	      }
	  }
      }
  }

  /**
   *
   * This method is used to effect the remote side of an bind operation.<br><br>
   *
   * An InvidDBField being manipulated with the standard editing accessors
   * (setValue, addElement, deleteElement, setElement) will call this method
   * on another InvidDBField in order to link a pair of symmetrically bound
   * InvidDBFields.<br><br>
   *
   * This method will return false if the binding could not be performed for
   * some reason.<br><br>
   *
   * <b>This method is private, and is not to be called by any code outside
   * of this class.</b>
   *
   * @param newInvid The invid to be linked to this field.
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   */

  private synchronized final ReturnVal establish(Invid newInvid, boolean local)
  {
    Invid 
      tmp = null;

    DBEditObject eObj;
    
    ReturnVal retVal = null;

    /* -- */

    // We wouldn't be called here unless this Object and InvidDBField
    // were editable.. bind checks things out for us.

    eObj = (DBEditObject) owner;

    if (isVector())
      {
	if (size() >= getMaxArraySize())
	  {
	    setLastError("InvidDBField remote establish: vector overrun");

	    return Ganymede.createErrorDialog("InvidDBField.establish(): field overrun",
					      "Couldn't establish a new linkage in vector field " + getName() +
					      " in object " + getOwner().getLabel() +
					      "because the vector field is already at maximum capacity");
	  }

	
	// only the backlinks field should ever be redundantly
	// linked.. since the backlinks field unbind logic will
	// automatically look for all links, we'll just go ahead and
	// ok this if we are already back-linked.

	if (getID() == SchemaConstants.BackLinksField && values.contains(newInvid))
	  {
	    return null;	// already linked
	  }

	// For everybody else, though, this is a no-no.

	if (values.contains(newInvid))
	  {
	    return Ganymede.createErrorDialog("InvidDBField.establish(): schema logic error",
					      "The backfield pointer in vector invid field " + getName() +
					      " in object " + getOwner().getLabel() + 
					      "refused the pointer binding because it already points " +
					      "back to the object requesting binding.  This sugests that " +
					      "multiple fields in the originating object " + newInvid + 
					      " are trying to link to one scalar field in we, the target, which " +
					      "can't work.  If one of the fields in " + newInvid + " is ever " +
					      "cleared or changed, we'll be cleared and the reflexive relationship " +
					      "will be broken.\n\nHave your adopter check the schema.");
	  }

	retVal = eObj.finalizeAddElement(this, newInvid);

	if (retVal == null || retVal.didSucceed())
	  {
	    values.addElement(newInvid);

	    return retVal;
	  }
	else
	  {
	    setLastError("InvidDBField remote establish: finalize returned false");

	    if (retVal.getDialog() != null)
	      {
		return Ganymede.createErrorDialog("InvidDBField.establish(): field addvalue refused",
						  "Couldn't establish a new linkage in vector field " + getName() +
						  " in object " + getOwner().getLabel() +
						  "because the custom plug in code for this object refused to " +
						  "approve the operation:\n\n" + retVal.getDialog().getText());
	      }
	    else
	      {
		return Ganymede.createErrorDialog("InvidDBField.establish(): field addvalue refused",
						  "Couldn't establish a new linkage in vector field " + getName() +
						  " in object " + getOwner().getLabel() +
						  "because the custom plug in code for this object refused to " +
						  "approve the operation.");
	      }
	  }
      }
    else
      {
	// ok, since we're scalar, *we* need to be unbound from *our* existing target
	// to be free to point back to our friend who is trying to establish a link
	// to us

	if (value != null)
	  {
	    tmp = (Invid) value;
	    
	    if (tmp.equals(newInvid))
	      {
		return Ganymede.createErrorDialog("InvidDBField.establish(): schema logic error",
						  "The backfield pointer in scalar invid field " + getName() +
						  " in object " + getOwner().getLabel() + 
						  "refused the pointer binding because it already points " +
						  "back to the object requesting binding.  This sugests that " +
						  "multiple fields in the originating object " + newInvid + 
						  " are trying to link to one scalar field in we, the target, which " +
						  "can't work.  If one of the fields in " + newInvid + " is ever " +
						  "cleared or changed, we'll be cleared and the reflexive relationship " +
						  "will be broken.\n\nHave your adopter check the schema.");
	      }

	    retVal = unbind(tmp, local);

	    if (retVal != null && !retVal.didSucceed())
	      {
		return retVal;
	      }
	  }

	ReturnVal newRetVal = eObj.finalizeSetValue(this, newInvid);

	if (newRetVal == null || newRetVal.didSucceed())
	  {
	    value = newInvid;

	    if (retVal != null)
	      {
		return retVal.unionRescan(newRetVal);
	      }
	    else
	      {
		return newRetVal;
	      }
	  }
	else
	  {
	    retVal = bind(null, tmp, local); // undo, should always work

	    if (retVal != null && !retVal.didSucceed())	
	      {
		throw new RuntimeException("couldn't rebind a value " + tmp + " we just unbound.. sync error");
	      }

	    if (newRetVal.getDialog() != null)
	      {
		return Ganymede.createErrorDialog("InvidDBField.establish(): field set value refused",
						  "Couldn't establish a new linkage in field " + getName() +
						  " in object " + getOwner().getLabel() +
						  "because the custom plug in code for this object refused to " +
						  "approve the operation:\n\n" + newRetVal.getDialog().getText());
	      }
	    else
	      {
		return Ganymede.createErrorDialog("InvidDBField.establish(): field set value refused",
						  "Couldn't establish a new linkage in field " + getName() +
						  " in object " + getOwner().getLabel() +
						  "because the custom plug in code for this object refused to " +
						  "approve the operation.");
	      }
	  }
      }
  }

  /**
   *
   * This method tests to see if the invid's held in this InvidDBField
   * are properly back-referenced.
   *
   */

  synchronized boolean test(DBSession session, String objectName)
  {
    Invid temp = null;
    Invid myInvid = getOwner().getInvid();
    short targetField;
    DBObject target;
    InvidDBField backField;
    boolean result = true;

    /* -- */

    // find out what the back-pointer field in the target object is

    if (getFieldDef().isSymmetric())
      {
	targetField = getFieldDef().getTargetField();
      }
    else
      {
	targetField = SchemaConstants.BackLinksField;
      }

    if (isVector())
      {
	// test for all values in our vector

	for (int i = 0; i < values.size(); i++)
	  {
	    temp = (Invid) values.elementAt(i);

	    if (temp == null)
	      {
		Ganymede.debug("HEEEEEYYYYY!!!!!");
	      }

	    // find the object that this invid points to

	    target = session.viewDBObject(temp);

	    if (target == null)
	      {
		Ganymede.debug("*** InvidDBField.test(): Invid pointer to null object located: " + 
			       objectName + " in field " + getName());
		result = false;

		continue;
	      }

	    // find the field that should contain the back-pointer
	    
	    try
	      {
		backField = (InvidDBField) target.getField(targetField);
	      }
	    catch (ClassCastException ex)
	      {
		String fieldName = ((DBField) target.getField(targetField)).getName();

		Ganymede.debug("**** InvidDBField.test(): schema error!  back-reference field not an invid field!!\n\t>" +
			       owner.lookupLabel(target) + ":" + fieldName + ", referenced from " + objectName +
			       ":" + getName());
		result = false;

		continue;
	      }

	    if (backField == null || !backField.isDefined())
	      {
		Ganymede.debug("InvidDBField.test(): Null backField field in targeted field: " + 
			       objectName + " in field " + getName());
		result = false;

		continue;
	      }

	    if (backField.isVector())
	      {
		if (backField.values == null)
		  {
		    Ganymede.debug("*** InvidDBField.test(): Null back-link invid found for invid " + 
				   temp + " in object " + objectName + " in field " + getName());
		    result = false;
		    
		    continue;
		  }
		else
		  {
		    boolean found = false;
		    Invid testInv;

		    /* -- */

		    for (int j = 0; !found && (j < backField.values.size()); j++)
		      {
			testInv = (Invid) backField.values.elementAt(j);

			if (myInvid.equals(testInv))
			  {
			    found = true;
			  }
		      }

		    if (!found)
		      {
			Ganymede.debug("*** InvidDBField.test(): No back-link invid found for invid " + 
				       temp + " in object " + objectName + ":" + getName() + " in " + 
				       backField.getName());
			result = false;
			
			continue;
		      }
		  }
	      }
	    else
	      {
		if ((backField.value == null) || !(backField.value.equals(myInvid)))
		  {
		    Ganymede.debug("*** InvidDBField.test(): <scalar> No back-link invid found for invid " + 
				   temp + " in object " + objectName + " in field " + getName());
		    result = false;
		    
		    continue;
		  }
	      }
	  }
      }
    else
      {
	temp = (Invid) value;

	if (temp != null)
	  {
	    target = session.viewDBObject(temp);

	    if (target == null)
	      {
		Ganymede.debug("*** InvidDBField.test(): Invid pointer to null object located: " + objectName);
	    
		return false;
	      }

	    try
	      {
		backField = (InvidDBField) target.getField(targetField);
	      }
	    catch (ClassCastException ex)
	      {
		Ganymede.debug("**** InvidDBField.test(): schema error!  back-reference field not an invid field!! " +
			       "field: " + getName() + " in object " + objectName);

		return false;
	      }

	    if (backField == null || !backField.isDefined())
	      {
		Ganymede.debug("*** InvidDBField.test(): No proper back-reference field in targeted field: " + 
			       objectName + ":" + getName());
	    
		return false;
	      }
	
	    if (backField.isVector())
	      {
		if (backField.values == null)
		  {
		    Ganymede.debug("*** InvidDBField.test(): Null back-link invid found for invid " + 
				   temp + " in object " + objectName + " in field " + getName());
		    
		    return false;
		  }
		else
		  {
		    boolean found = false;
		    Invid testInv;

		    for (int j = 0; !found && (j < backField.values.size()); j++)
		      {
			testInv = (Invid) backField.values.elementAt(j);

			if (myInvid.equals(testInv))
			  {
			    found = true;
			  }
		      }

		    if (!found)
		      {
			Ganymede.debug(">>> InvidDBField.test(): No back-link invid found for invid " + 
				       temp + " in object " + objectName + ":" + getName() + " in " + 
				       backField.getName());

			return false;
		      }
		  }
	      }
	    else
	      {
		if ((backField.value == null) || !(backField.value.equals(myInvid)))
		  {
		    Ganymede.debug("*** InvidDBField.test(): <scalar> No back-link invid found for invid " + 
				   temp + " in object " + objectName + ":" + getName());
		    
		    return false;
		  }
	      }
	  }
      }

    return result;
  }

  // ****
  //
  // InvidDBField is a special kind of DBField in that we have symmetry
  // maintenance issues to handle.  We're overriding all DBField field-changing
  // methods to include symmetry maintenance code.
  //
  // ****

  /**
   *
   * Sets the value of this field, if a scalar.<br><br>
   *
   * The Invid we are passed must refer to a valid object in the
   * database.  The remote object will be checked out for
   * editing and a backpointer will placed in it.  If this field
   * previously held a pointer to another object, that other
   * object will be checked out and its pointer to us cleared.<br><br>
   *
   * The ReturnVal object returned encodes success or failure, and may
   * optionally pass back a dialog.
   *
   * @param value the value to set this field to, and Invid
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   * @see arlut.csd.ganymede.DBSession
   * 
   */

  public synchronized ReturnVal setValue(Object value, boolean local)
  {
    DBEditObject eObj;
    Invid oldRemote, newRemote;
    ReturnVal retVal = null, newRetVal;
    boolean checkpoint = false;
    String checkkey = null;

    /* -- */

    if (!isEditable(local))
      {
	return Ganymede.createErrorDialog("InvidDBField.setValue()",
					  "don't have permission to change field /  non-editable object: " +
					   getName() + " in object " + owner.getLabel());
      }

    if (isVector())
      {
	throw new IllegalArgumentException("scalar method called on a vector field: " + getName() +
					   " in object " + owner.getLabel());
      }

    if ((this.value == null && value == null) ||
	(this.value != null && this.value.equals(value)))
      {
	if (debug)
	  {
	    Ganymede.debug("InvidDBField.setValue(): no change");
	  }

	return null;		// no change
      }

    retVal = verifyNewValue(value, local);

    if (retVal != null && !retVal.didSucceed())
      {
	return retVal;
      }

    // we now know that value is an invid
    
    oldRemote = (Invid) this.value;
    newRemote = (Invid) value;

    eObj = (DBEditObject) owner;

    if (!local && eObj.getGSession().enableOversight)
      {
	// Wizard check
	
	retVal = eObj.wizardHook(this, DBEditObject.SETVAL, value, null);

	// if a wizard intercedes, we are going to let it take the ball.
	
	if (retVal != null && !retVal.doNormalProcessing)
	  {
	    return retVal;
	  }
      }

    // if we are doing bulk-loaded, we don't want to go through the
    // time consuming checkpoint() operation for each invid link.

    checkpoint = eObj.getGSession().enableOversight;

    if (checkpoint)
      {
	checkkey = "setValue" + getName() + owner.getLabel();

	eObj.getSession().checkpoint(checkkey);
      }

    // try to do the binding

    if (newRemote != null)
      {
	newRetVal = bind(oldRemote, newRemote, local);

	if (newRetVal != null && !newRetVal.didSucceed())
	  {
	    if (checkpoint)
	      {
		eObj.getSession().rollback(checkkey);
	      }

	    return newRetVal;
	  }

	if (retVal != null)
	  {
	    retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    retVal = newRetVal;
	  }
      }
    else if (oldRemote != null)
      {
	newRetVal = unbind(oldRemote, local);
	
	if (newRetVal != null && !newRetVal.didSucceed())
	  {
	    if (checkpoint)
	      {
		eObj.getSession().rollback(checkkey);
	      }

	    return newRetVal;
	  }

	if (retVal != null)
	  {
	    retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    retVal = newRetVal;
	  }
      }

    // check our owner, do it.  Checking our owner should
    // be the last thing we do.. if it returns true, nothing
    // should stop us from running the change to completion

    this.newValue = value;

    newRetVal = eObj.finalizeSetValue(this, value);

    if (newRetVal == null || newRetVal.didSucceed())
      {
	this.value = value;

	this.newValue = null;

	if (checkpoint)
	  {
	    eObj.getSession().popCheckpoint(checkkey);
	  }

	if (retVal != null)
	  {
	    return retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    return newRetVal;
	  }
      }
    else
      {
	this.newValue = null;

	if (checkpoint)
	  {
	    eObj.getSession().rollback(checkkey);
	  }

	return newRetVal;
      }
  }

  /**
   *
   * Sets the value of an element of this field, if a vector.<br><br>
   *
   * The Invid we are passed must refer to a valid object in the
   * database.  The remote object will be checked out for
   * editing and a backpointer will placed in it.  If this field
   * previously held a pointer to another object, that other
   * object will be checked out and its pointer to us cleared.<br><br>
   *
   * The ReturnVal object returned encodes success or failure, and may
   * optionally pass back a dialog.<br><br>
   *
   * It is an error to call this method on an edit in place vector,
   * or on a scalar field.  An IllegalArgumentException will be thrown
   * in these cases.
   *
   * @param index The index of the element in this field to change.
   * @param value The value to put into this vector.
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   *
   * @see arlut.csd.ganymede.DBSession
   *
   */
  
  public synchronized ReturnVal setElement(int index, Object value, boolean local)
  {
    DBEditObject eObj;
    Invid oldRemote, newRemote;
    ReturnVal retVal = null, newRetVal;
    boolean checkpoint = false;
    String checkkey = null;

    /* -- */

    // DBField.setElement(), DBField.setElementLocal() check the index and value
    // params for us.

    if (isEditInPlace())
      {
	throw new IllegalArgumentException("can't manually set element in edit-in-place vector: " +
					   getName() + " in object " + owner.getLabel());
      }

    if (!isEditable(local))
      {
	return Ganymede.createErrorDialog("InvidDBField.setElement()",
					  "don't have permission to change field /  non-editable object: " +
					  getName() + " in object " + owner.getLabel());
      }

    if (this.value.equals(values.elementAt(index)))
      {
	if (debug)
	  {
	    Ganymede.debug("InvidDBField.setElement(): no change");
	  }

	return null;		// no change
      }

    retVal = verifyNewValue(value, local);

    if (retVal != null && !retVal.didSucceed())
      {
	return retVal;
      }

    eObj = (DBEditObject) owner;

    if (!local && eObj.getGSession().enableOversight)
      {
	// Wizard check

	retVal = eObj.wizardHook(this, DBEditObject.SETELEMENT, new Integer(index), value);

	// if a wizard intercedes, we are going to let it take the ball.
	
	if (retVal != null && !retVal.doNormalProcessing)
	  {
	    return retVal;
	  }
      }

    oldRemote = (Invid) values.elementAt(index);
    newRemote = (Invid) value;

    // if we are doing bulk-loaded, we don't want to go through the
    // time consuming checkpoint() operation for each invid link.

    checkpoint = eObj.getGSession().enableOversight;

    if (checkpoint)
      {
	checkkey = "setElement" + getName() + owner.getLabel();
	eObj.getSession().checkpoint(checkkey);
      }
    
    // try to do the binding

    newRetVal = bind(oldRemote, newRemote, local);

    if (newRetVal != null && !newRetVal.didSucceed())
      {
	if (checkpoint)
	  {
	    eObj.getSession().rollback(checkkey);
	  }

	return newRetVal;
      }

    if (retVal != null)
      {
	retVal.unionRescan(newRetVal);
      }
    else
      {
	retVal = newRetVal;
      }

    // check our owner, do it.  Checking our owner should
    // be the last thing we do.. if it returns true, nothing
    // should stop us from running the change to completion

    newRetVal = eObj.finalizeSetElement(this, index, value);

    if (newRetVal == null || newRetVal.didSucceed())
      {
	values.setElementAt(value, index);

	if (checkpoint)
	  {
	    eObj.getSession().popCheckpoint(checkkey);
	  }

	if (retVal != null)
	  {
	    return retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    return newRetVal;
	  }
      }
    else
      {
	if (checkpoint)
	  {
	    eObj.getSession().rollback(checkkey);
	  }

	return newRetVal;
      }
  }

  /**
   *
   * Adds an element to the end of this field, if a vector.<br><br>
   *
   * The Invid we are passed must refer to a valid object in the
   * database.  The remote object will be checked out for
   * editing and a backpointer will placed in it.  If this field
   * previously held a pointer to another object, that other
   * object will be checked out and its pointer to us cleared.<br><br>
   *
   * The ReturnVal object returned encodes success or failure, and may
   * optionally pass back a dialog.<br><br>
   *
   * It is an error to call this method on an edit in place vector,
   * or on a scalar field.  An IllegalArgumentException will be thrown
   * in these cases.
   *
   * @param value The value to put into this vector.
   * @param local if true, this operation will be performed without regard
   * to permissions limitations.
   * 
   */

  public synchronized ReturnVal addElement(Object value, boolean local)
  {
    DBEditObject eObj;
    Invid remote;
    ReturnVal retVal = null, newRetVal;
    boolean checkpoint = false;
    String checkkey = null;

    /* -- */

    if (isEditInPlace())
      {
	return Ganymede.createErrorDialog("InvidDBFIeld.addElement()",
					  "can't manually add element to edit-in-place vector" +
					  getName() + " in object " + owner.getLabel());
      }

    if (!isEditable(local))	// *sync* on GanymedeSession possible
      {
	return Ganymede.createErrorDialog("InvidDBFIeld.addElement()",
					  "don't have permission to change field /  non-editable object " +
					  getName() + " in object " + owner.getLabel());
      }

    if (!isVector())
      {
	setLastError("vector accessor called on scalar field");
	throw new IllegalArgumentException("vector accessor called on scalar field " +
					   getName() + " in object " + owner.getLabel());
      }

    if (this.values.contains(value))
      {
	return Ganymede.createErrorDialog("InvidDBField.addElement() - redundant value submitted",
					  "Field " + getName() + " already contains value " + value);
      }

    retVal = verifyNewValue(value, local);

    if (retVal != null && !retVal.didSucceed())
      {
	return retVal;
      }

    if (size() >= getMaxArraySize())
      {
	return Ganymede.createErrorDialog("InvidDBField.addElement() - vector overflow",
					  "Field " + getName() +
					  " already at or beyond array size limit");
      }

    remote = (Invid) value;

    eObj = (DBEditObject) owner;

    if (!local && eObj.getGSession().enableOversight)
      {
	// Wizard check

	retVal = eObj.wizardHook(this, DBEditObject.ADDELEMENT, value, null);

	// if a wizard intercedes, we are going to let it take the ball.
	
	if (retVal != null && !retVal.doNormalProcessing)
	  {
	    return retVal;
	  }
      }

    // if we are doing bulk-loaded, we don't want to go through the
    // time consuming checkpoint() operation for each invid link.

    checkpoint = eObj.getGSession().enableOversight;

    if (checkpoint)
      {
	checkkey = "addElement" + getName() + owner.getLabel();

	eObj.getSession().checkpoint(checkkey);
      }

    newRetVal = bind(null, remote, local);

    if (newRetVal != null && !newRetVal.didSucceed())
      {
	if (checkpoint)
	  {
	    eObj.getSession().rollback(checkkey);
	  }

	return newRetVal;
      }

    if (retVal != null)
      {
	retVal.unionRescan(newRetVal);
      }
    else
      {
	retVal = newRetVal;
      }

    newRetVal = eObj.finalizeAddElement(this, value);

    if (newRetVal == null || newRetVal.didSucceed())
      {
	values.addElement(value);

	if (checkpoint)
	  {
	    eObj.getSession().popCheckpoint(checkkey);
	  }

	if (retVal != null)
	  {
	    return retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    return newRetVal;
	  }
      } 
    else
      {
	if (checkpoint)
	  {
	    eObj.getSession().rollback(checkkey);
	  }

	return newRetVal;
      }
  }

  /**
   *
   * This method is used to create a new embedded object in an
   * invid field that contains a vector of edit-in-place/embedded
   * objects.  The ReturnVal returned indicates success/failure,
   * and on success will provide the Invid of the newly created
   * embedded when ReturnVal.getInvid() is called on it.
   *
   *
   * @see arlut.csd.ganymede.invid_field
   */

  public ReturnVal createNewEmbedded()
  {
    return createNewEmbedded(false);
  }

  /**
   *
   * Creates and adds a new embedded object in this
   * field, if it is an edit-in-place vector.<br><br>
   *
   * Returns an Invid pointing to the newly created and appended
   * embedded object, or null if creation / addition was not possible.
   *
   * @param local If true, we don't check permission to edit this
   * field before creating the new object.
   * 
   */

  public synchronized ReturnVal createNewEmbedded(boolean local)
  {
    if (!isEditable(local))
      {
	return Ganymede.createErrorDialog("InvidDBField.createNewEmbedded()",
					  "don't have permission to change field /  non-editable object: " +
					  getName() + " in object " + owner.getLabel());
      }

    if (!isVector())
      {
	throw new IllegalArgumentException("vector method called on a scalar field " +
					   getName() + " in object " + owner.getLabel());
      }

    if (!isEditInPlace())
      {
	throw new IllegalArgumentException("edit-in-place method called on a referential invid field " +
					   getName() + " in object " + owner.getLabel());
      }

    if (size() >= getMaxArraySize())
      {
	return Ganymede.createErrorDialog("Field overflow",
					  "Field " + getName() +
					  " is already at or beyond the specified array size limit.");
      }

    DBEditObject eObj = (DBEditObject) owner;

    // have our owner create a new embedded object
    // for us 

    Invid newObj = eObj.createNewEmbeddedObject(this);

    if (newObj == null)
      {
	return Ganymede.createErrorDialog("Couldn't create new embedded object",
					  "An error occurred in trying to create a new embedded object in the " +
					  getName() + " field.\n\nThis may be due to a permissions problem");
      }

    // now we need to do the binding as appropriate.

    // Note that we are just taking it for granted that we can edit
    // the newly created object.  This is the right thing to do.  The
    // permissions system in GanymedeSession wouldn't know how to
    // check this operation until we link the newly embedded object
    // into its container anyway.

    DBEditObject embeddedObj = (DBEditObject) owner.editset.getSession().editDBObject(newObj); // *sync* DBSession DBObject

    if (embeddedObj == null)
      {
	throw new NullPointerException("gah, null embedded obj!");
      }

    // bind the object to its container.. note that ContainerField
    // is a standard built-in field for embedded objects and as
    // such it doesn't have the specific details as to the containing
    // object's binding recorded.  We'll have to do the bidirectional
    // binding ourselves, in two steps.

    // we have to use setFieldValueLocal() here because the
    // permissions system uses the ContainerField to determine rights
    // to modify the field.. since we are just now setting the
    // container, the permissions system will fail if we don't bypass
    // it by using the local variant.

    ReturnVal retVal = embeddedObj.setFieldValueLocal(SchemaConstants.ContainerField, // *sync* DBField
						      owner.getInvid());

    if (retVal != null && !retVal.didSucceed())
      {
	return retVal;
      }
    else if (debug)
      {
	InvidDBField invf = (InvidDBField)  embeddedObj.getField(SchemaConstants.ContainerField);

	if (debug)
	  {
	    System.err.println("-- Created a new embedded object in " + owner.getLabel() + 
			       ", set it's container pointer to " + invf.getValueString());
	  }
      }

    // finish the binding.  Note that we are directly modifying values
    // here rather than going to this.addElement().  If we did
    // this.addElement(), we might get a redundant attempt to do the
    // invid binding, as the containing field may indeed have the
    // reverse pointer in the object's container field specified in
    // the schema.  Doing it this way, we don't have to worry about
    // whether the admins got this part of the schema right.

    if (!local && eObj.getGSession().enableOversight)
      {
	// Wizard check

	retVal = eObj.wizardHook(this, DBEditObject.ADDELEMENT, newObj, null);

	// if a wizard intercedes, we are going to let it take the ball.
	
	if (retVal != null && !retVal.doNormalProcessing)
	  {
	    return retVal;
	  }
      }

    ReturnVal newRetVal = eObj.finalizeAddElement(this, newObj);

    if (newRetVal == null || newRetVal.didSucceed())
      {
	values.addElement(newObj);

	if (debug)
	  {
	    setLastError("InvidDBField debug: successfully added " + newObj);
	  }

	if (retVal == null)
	  {
	    retVal = new ReturnVal(true);
	  }

	retVal.setInvid(newObj);

	return retVal.unionRescan(newRetVal);
      } 
    else
      {
	embeddedObj.setFieldValue(SchemaConstants.ContainerField, null); // *sync* DBField

	if (newRetVal.getDialog() != null)
	  {
	    return Ganymede.createErrorDialog("Couldn't create embedded object",
					      "The custom code for this object type refused to okay adding " +
					      "a new embedded object.  It was created though..\n\n" +
					      newRetVal.getDialog().getText());
	  }
	else
	  {
	    return Ganymede.createErrorDialog("Couldn't create embedded object",
					      "The custom code for this object type refused to okay adding " +
					      "a new embedded object.  It was created though..");
	  }
      }
  }

  /**
   *
   * <p>Return the object type that this invid field is constrained to point to, if set</p>
   *
   * <p>-1 means there is no restriction on target type.</p>
   *
   * <p>-2 means there is no restriction on target type, but there is a specified symmetric field.</p>
   *
   * @see arlut.csd.ganymede.invid_field
   */

  public short getTargetBase()
  {
    return definition.getTargetBase();
  }

  /**
   *
   * Deletes an element of this field, if a vector.<br><br>
   *
   * The object pointed to by the Invid in the element to be deleted 
   * will be checked out of the database and its pointer to us cleared.<br><br>
   *
   * Returns null on success, non-null on failure.<br><br>
   *
   * If non-null is returned, the ReturnVal object
   * will include a dialog specification that the
   * client can use to display the error condition.
   *
   */

  public synchronized ReturnVal deleteElement(int index, boolean local)
  {
    DBEditObject eObj;
    Invid remote;
    ReturnVal retVal = null, newRetVal;
    boolean checkpoint = false;
    String checkkey = null;

    /* -- */

    if (!isEditable(local))
      {
	return Ganymede.createErrorDialog("InvidDBField.deleteElement()",
					  "don't have permission to change field /  non-editable object " +
					  getName() + " in object " + owner.getLabel());
      }

    if (!isVector())
      {
	throw new IllegalArgumentException("vector accessor called on scalar field " +
					   getName() + " in object " + owner.getLabel());
      }

    if ((index < 0) || (index >= values.size()))
      {
	throw new IllegalArgumentException("invalid index " + index + 
					   getName() + " in object " + owner.getLabel());
      }

    remote = (Invid) values.elementAt(index);

    eObj = (DBEditObject) owner;

    checkkey = "del" + remote.toString();

    if (!local && eObj.getGSession().enableOversight)
      {
	// Wizard check

	retVal = eObj.wizardHook(this, DBEditObject.DELELEMENT, new Integer(index), null);

	// if a wizard intercedes, we are going to let it take the ball.
	
	if (retVal != null && !retVal.doNormalProcessing)
	  {
	    return retVal;
	  }
      }

    // ok, we're going to handle it.  Checkpoint
    // so we can easily undo any changes that we make
    // if we have to return failure.

    if (debug)
      {
	System.err.println("][ InvidDBField.deleteElement() checkpointing " + checkkey);
      }

    // if we are doing bulk-loaded, we don't want to go through the
    // time consuming checkpoint() operation for each invid link.

    checkpoint = eObj.getGSession().enableOversight;

    if (checkpoint)
      {
	eObj.getSession().checkpoint(checkkey);
      }

    if (debug)
      {
	System.err.println("][ InvidDBField.deleteElement() checkpointed " + checkkey);
      }

    // if we are an edit in place object, we don't want to do an
    // unbinding.. we'll do a deleteDBObject() below, instead.  The
    // reason for this is that the deleteDBObject() code requires that
    // the SchemaConstants.ContainerField field be intact to properly
    // check permissions for embedded objects.

    if (!getFieldDef().isEditInPlace())
      {
	newRetVal = unbind(remote, local);

	if (newRetVal != null && !newRetVal.didSucceed())
	  {
	    return newRetVal;
	  }

	if (retVal != null)
	  {
	    retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    retVal = newRetVal;
	  }
      }

    // finalizeDeleteElement() just gives the DBEditObject a chance to
    // approve or disapprove deleting an element from this field
    
    newRetVal = eObj.finalizeDeleteElement(this, index);

    if (newRetVal == null || newRetVal.didSucceed())
      {
	values.removeElementAt(index);

	if (retVal != null)
	  {
	    retVal.unionRescan(newRetVal);
	  }
	else
	  {
	    retVal = newRetVal;
	  }

	// if we are an editInPlace field, unlinking this object means
	// that we should go ahead and delete the object.

	if (getFieldDef().isEditInPlace())
	  {
	    newRetVal = eObj.getSession().deleteDBObject(remote);

	    if (newRetVal != null && !newRetVal.didSucceed())
	      {
		if (checkpoint)
		  {
		    eObj.getSession().rollback(checkkey);
		  }

		return newRetVal;	// go ahead and return our error code
	      }

	    if (retVal != null)
	      {
		retVal.unionRescan(newRetVal);
	      }
	    else
	      {
		retVal = newRetVal;
	      }
	  }

	// success

	if (checkpoint)
	  {
	    eObj.getSession().popCheckpoint(checkkey);
	  }

	return retVal;
      }
    else
      {
	if (checkpoint)
	  {
	    eObj.getSession().rollback(checkkey);
	  }

	if (newRetVal.getDialog() != null)
	  {
	    return Ganymede.createErrorDialog("InvidDBField.deleteElement() - custom code rejected element deletion",
					      "Couldn't finalize\n\n" + newRetVal.getDialog().getText());
	  }
	else
	  {
	    return Ganymede.createErrorDialog("InvidDBField.deleteElement() - custom code rejected element deletion",
					      "Couldn't finalize\n" + getLastError());
	  }
      }
  }

  // ****
  //
  // invid_field methods
  //
  // ****

  /**
   *
   * Returns true if this invid field may only point to objects
   * of a particular type.
   * 
   * @see arlut.csd.ganymede.invid_field 
   *
   */

  public boolean limited()
  {
    return definition.isTargetRestricted();
  }

  /**
   *
   * Returns the object type permitted for this field if this invid
   * field may only point to objects of a particular type.
   * 
   * @see arlut.csd.ganymede.invid_field 
   * 
   */

  public int getAllowedTarget()
  {
    return definition.getTargetBase();
  }

  /**
   *
   * Returns a QueryResult encoded list of the current values
   * stored in this field.
   *
   * @see arlut.csd.ganymede.invid_field
   *
   */

  public synchronized QueryResult encodedValues()
  {
    QueryResult results = new QueryResult();
    Invid invid;
    String label;
    DBObject object;
    GanymedeSession gsession = null;

    /* -- */

    if (!isVector())
      {
	throw new IllegalArgumentException("can't call encodedValues on scalar field: " +
					   getName() + " in object " + owner.getLabel());
      }

    try
      {
	if (owner.editset != null)
	  {
	    gsession = owner.editset.getSession().getGSession();
	  }
      }
    catch (NullPointerException ex)
      {
      }

    if (gsession == null)
      {
	gsession = Ganymede.internalSession;
      }

    for (int i = 0; i < values.size(); i++)
      {
	invid = (Invid) values.elementAt(i);

	if (gsession != null)
	  {
	    object = gsession.getSession().viewDBObject(invid);

	    if (object == null)
	      {
		Ganymede.debug("Error in InvidDBField field <" + owner.getLabel() + ":" + getName() +
			       "> encodedValues() method.. couldn't " +
			       "view invid " + invid.toString() + " to pull its label");

		label = invid.toString();
	      }
	    else
	      {
		// use lookupLabel because our owner may wish to construct a custom
		// label for the object.. different objects may display the name
		// of a referenced object differently.
		
		if (owner instanceof DBEditObject)
		  {
		    label = owner.lookupLabel(object);
		  }
		else
		  {
		    label = owner.getBase().getObjectHook().lookupLabel(object);
		  }
	      }
	  }
	else
	  {
	    label = invid.toString();
	  }
	
	if (label != null)
	  {
	    results.addRow(invid, label, false); // we're not going to report the values as editable here
	  }
      }

    return results;
  }

  /**
   *
   * This method returns true if this invid field should not
   * show any choices that are currently selected in field
   * x, where x is another field in this db_object.
   *
   */

  public boolean excludeSelected(db_field x)
  {
    return ((DBEditObject) owner).excludeSelected(x, this);    
  }

  /**
   *
   * Returns true if the only valid values for this invid field are in
   * the QueryRersult returned by choices().  In particular, if mustChoose()
   * returns true, <none> is not an acceptable choice for this field
   * after the field's value is initially set.
   *
   * @see arlut.csd.ganymede.invid_field
   *
   */

  public boolean mustChoose()
  {
    if (owner instanceof DBEditObject)
      {
	return ((DBEditObject) owner).mustChoose(this);
      }
    else
      {
	throw new IllegalArgumentException("can't call mustChoose on an invid field in a non-editable context.");
      }
  }

  /**
   *
   * Returns a StringBuffer encoded list of acceptable invid values
   * for this field.
   *
   * @see arlut.csd.ganymede.invid_field
   * 
   */

  public QueryResult choices()
  {
    DBEditObject eObj;

    /* -- */

    if (!isEditable(true))
      {
	throw new IllegalArgumentException("not an editable field: " + 
					   getName() + " in object " + owner.getLabel());
      }

    eObj = (DBEditObject) owner;

    return eObj.obtainChoiceList(this);
  }

  /**
   * <p>This method returns a key that can be used by the client
   * to cache the value returned by choices().  If the client
   * already has the key cached on the client side, it
   * can provide the choice list from its cache rather than
   * calling choices() on this object again.</p>
   *
   * <p>If there is no caching key, this method will return null.</p>
   */

  public Object choicesKey()
  {
    if (owner instanceof DBEditObject)
      {
	Object key = ((DBEditObject) owner).obtainChoicesKey(this);

	// we have to be careful not to let the client try to use
	// its cache if our choices() method will return items that
	// they would normally not be able to access

	if (key != null)
	  {
	    if (((DBEditObject) owner).choiceListHasExceptions(this))
	      {
		return null;
	      }
	  }

	return key;
      }
    else
      {
	return null;
      }
  }

  // ****
  //
  // Overridable methods for implementing intelligent behavior
  //
  // ****

  public boolean verifyTypeMatch(Object o)
  {
    return ((o == null) || (o instanceof Invid));
  }

  public ReturnVal verifyNewValue(Object o)
  {
    return verifyNewValue(o, false);
  }

  public ReturnVal verifyNewValue(Object o, boolean local)
  {
    DBEditObject eObj;
    Invid inv, inv2;
    boolean ok;
    QueryResult qr;

    /* -- */

    if (!isEditable(true))
      {
	return Ganymede.createErrorDialog("Invid Field Error",
					  "Don't have permission to edit field " + getName() +
					  " in object " + owner.getLabel());
      }

    eObj = (DBEditObject) owner;

    if (!verifyTypeMatch(o))
      {
	return Ganymede.createErrorDialog("Invid Field Error",
					  "Submitted value " + o + " is not an invid!  Major client error while" +
					  " trying to edit field " + getName() +
					  " in object " + owner.getLabel());
      }

    inv = (Invid) o;

    if (inv != null)
      {
	if (limited() && (getAllowedTarget() != -2) &&
	    (inv.getType() != getAllowedTarget()))
	  {
	    // the invid points to an object of the wrong type

	    return Ganymede.createErrorDialog("Invid Field Error",
					      "invid value " + inv + 
					      " points to the wrong kind of" +
					      " object for field " +
					      getName() + " in object " + owner.getLabel() +
					      " which should point to an" +
					      " object of type " + 
					      getAllowedTarget());
	  }

	if (!local && mustChoose())
	  {
	    ok = false;
	    qr = choices();

	    if (qr != null)
	      {
		if (debug)
		  {
		    Ganymede.debug("InvidDBField.verifyNewValue(): searching for matching choice");
		  }

		for (int i = 0; i < qr.size() && !ok; i++)
		  {
		    inv2 = qr.getInvid(i);

		    if (debug)
		      {
			Ganymede.debug("InvidDBField.verifyNewValue(): comparing " + inv + " to " + inv2);
		      }
		    
		    if (inv2.equals(inv))
		      {
			ok = true;
		      }
		  }
	      }

	    if (!ok)
	      {
		return Ganymede.createErrorDialog("Invid Field Error",
						  "invid value " + inv + 
						  " is not a valid choice for field" +
						  getName() + " in object " + owner.getLabel() +
						  ".  Serious client error?");
	      }
	  }
      }

    // have our parent make the final ok on the value

    return eObj.verifyNewValue(this, o);
  }
}
