/*

   DBBaseCategory.java

   This module represents an objectbase folder in the server's
   category hierarchy.
   
   Created: 11 August 1997
   Version: $Revision: 1.12 $ %D%
   Module By: Jonathan Abbey
   Applied Research Laboratories, The University of Texas at Austin

*/

package arlut.csd.ganymede;

import arlut.csd.Util.*;

import java.io.*;
import java.util.*;
import java.rmi.*;
import java.rmi.server.UnicastRemoteObject;


/*------------------------------------------------------------------------------
                                                                           class
                                                                  DBBaseCategory

------------------------------------------------------------------------------*/

/**
 *
 * This class represents an objectbase folder in the server's
 * category hierarchy.
 *
 */

public class DBBaseCategory extends UnicastRemoteObject implements Category, CategoryNode {

  private final static boolean debug = false;

  //

  private String name;
  private int displayOrder;
  private DBBaseCategory parent;
  private DBStore store;
  private Vector contents;

  /**
   *
   * We use this baseHash to keep a map of DBObjectBase.getKey() to
   * instances of DBObjectBase.  addNode() uses this to find a
   * server-local DBObjectBase from a remote Base reference passed
   * us by the schema editor on the client.
   *
   */

  private Hashtable baseHash;

  /**
   *
   * A reference to the DBSchemaEdit object that is editing us
   * for a client-side schema editor.
   *
   */

  private DBSchemaEdit editor = null;

  /* -- */

  /**
   *
   * Primary constructor.
   *
   * @param store DBStore that is managing us.  We'll ask it to look up parents
   * for us.
   *
   * @param parent If we're not being constructed at the top level, who is our parent?
   *
   */

  public DBBaseCategory(DBStore store, String name, DBBaseCategory parent) throws RemoteException
  {
    super();			// UnicastRemoteObject initialization

    this.setName(name);
    this.store = store;
    this.parent = parent;

    // All children of a top-level baseHash generated by recurseDown will
    // share a single baseHash so they can properly re-install a base if it
    // is moved around in the tree.

    if (parent != null)
      {
	this.baseHash = parent.baseHash;
	this.editor = parent.editor;
      }

    contents = new Vector();
  }

  /**
   *
   * Default value constructor.  This is used to construct a top-level category.
   *
   * @param store DBStore that is managing us.  We'll ask it to look up parents
   * for us.
   *
   * @param name Name for this category
   *
   */

  public DBBaseCategory(DBStore store, String name) throws RemoteException
  {
    this(store, name, null);
  }

  /**
   *
   * Receive constructor.
   *
   * @param store DBStore that is managing us.  We'll ask it to look up parents
   * for us.
   *
   * @param in DataInput stream to load the db representation of this category from
   *
   */

  public DBBaseCategory(DBStore store, DataInput in) throws RemoteException, IOException
  {
    super();			// UnicastRemoteObject initialization

    this.store = store;
    contents = new Vector();
    receive(in, null);
  }


  /**
   *
   * Receive constructor.
   *
   * @param store DBStore that is managing us.  We'll ask it to look up parents
   * for us.
   *
   * @param in DataInput stream to load the db representation of this category from
   *
   */

  public DBBaseCategory(DBStore store, DataInput in, DBBaseCategory parent) throws RemoteException, IOException
  {
    super();			// UnicastRemoteObject initialization

    this.store = store;
    contents = new Vector();
    receive(in, parent);
  }

  /**
   *
   * Recursive duplication constructor.  This constructor recurses down
   * through the newly created DBBaseCategory and creates copies of
   * the bases and categories therein.
   *
   */

  public DBBaseCategory(DBStore store, DBBaseCategory rootCategory,
			Hashtable baseHash, DBSchemaEdit editor) throws RemoteException
  {
    this.editor = editor;
    this.store = store;
    contents = new Vector();

    this.baseHash = baseHash;

    setName(rootCategory.getName());
    setDisplayOrder(rootCategory.getDisplayOrder());
    
    recurseDown(rootCategory, baseHash, editor);
  }

  /**
   *
   * This method takes all the children of the passed-in category
   * (both DBObjectBase objects and contained DBBaseCategory objects)
   * and makes copies under this.
   * 
   */

  private void recurseDown(DBBaseCategory category, Hashtable baseHash, DBSchemaEdit editor) throws RemoteException
  {
    Vector children = category.getNodes();
    CategoryNode node;
    DBObjectBase oldBase, newBase;
    DBBaseCategory oldCategory, newCategory;

    /* -- */

    if (debug)
      {
	Ganymede.debug("** recurseDown");

	if (editor == null)
	  {
	    Ganymede.debug("**#?!?!!! DBBaseCategory.recurseDown(): editor == null!!!");
	  }
      }

    for (int i = 0; i < children.size(); i++)
      {
	node = (CategoryNode) children.elementAt(i);

	if (node instanceof DBObjectBase)
	  {
	    oldBase = (DBObjectBase) node;
	    newBase = new DBObjectBase(oldBase, editor); // a new copy, with the same objects under it
	    baseHash.put(newBase.getKey(), newBase);

	    // let the base know what hash to check for name collisions

	    newBase.setContainingHash(baseHash);

	    if (debug)
	      {
		Ganymede.debug("Created newBase " + newBase.getName() + " in recursive category tree duplication");
	      }

	    addNode(newBase, false, false);

	    if (debug)
	      {
		Ganymede.debug("Added " + newBase.getName() + " to new category tree");
	      }
	  }
	else if (node instanceof DBBaseCategory)
	  {
	    oldCategory = (DBBaseCategory) node;
	    newCategory = (DBBaseCategory) newSubCategory(oldCategory.getName());
	    newCategory.editor = editor;

	    if (debug)
	      {
		Ganymede.debug("Created newCategory " + newCategory.getName() + " in recursive category tree duplication");
	      }

	    newCategory.recurseDown(oldCategory, baseHash, editor);
	  }
      }
  }

  /**
   *
   * This method is used when a schema editor is 'checking in'
   * a category tree.
   *
   */

  public synchronized void clearEditor()
  {
    CategoryNode node;

    /* -- */

    this.editor = null;

    for (int i = 0; i < contents.size(); i++)
      {
	node = (CategoryNode) contents.elementAt(i);

	if (node instanceof DBBaseCategory)
	  {
	    ((DBBaseCategory) node).clearEditor();
	  }
      }
  }

  public synchronized void printHTML(PrintWriter out)
  {
    out.print("<H2>");
    out.print(getName());
    out.println("</H2>");

    out.println("<UL>");

    for (int i = 0; i < contents.size(); i++)
      {
	out.println("<LI>");

	if (contents.elementAt(i) instanceof DBBaseCategory)
	  {
	    ((DBBaseCategory) contents.elementAt(i)).printHTML(out);
	  }
	else if (contents.elementAt(i) instanceof DBObjectBase)
	  {
	    ((DBObjectBase) contents.elementAt(i)).printHTML(out);
	  }

	out.println("</LI>");
      }

    out.println("</UL>");
  }

  public synchronized void print(PrintWriter out, String indent)
  {
    out.println(indent + getName());

    for (int i = 0; i < contents.size(); i++)
      {
	if (contents.elementAt(i) instanceof DBBaseCategory)
	  {
	    ((DBBaseCategory) contents.elementAt(i)).print(out, indent + "  ");
	  }
	else if (contents.elementAt(i) instanceof DBObjectBase)
	  {
	    ((DBObjectBase) contents.elementAt(i)).print(out, indent + "  ");
	  }
      }
  }

  synchronized void emit(DataOutput out) throws IOException
  {
    int count = 0;
    DBBaseCategory bc;

    /* -- */

    for (int i = 0; i < contents.size(); i++)
      {
	if (contents.elementAt(i) instanceof DBBaseCategory)
	  {
	    count++;
	  }
      }

    out.writeUTF(this.getPath());
    out.writeInt(displayOrder);
    out.writeInt(count);
    
    for (int i = 0; i < contents.size(); i++)
      {
	if (contents.elementAt(i) instanceof DBBaseCategory)
	  {
	    bc = (DBBaseCategory) contents.elementAt(i);
	    bc.emit(out);
	  }
      }
  }

  synchronized void receive(DataInput in, DBBaseCategory parent) throws IOException
  {
    String 
      pathName,
      path;

    int 
      count,
      lastSlash;

    /* -- */

    pathName = in.readUTF();
    displayOrder = in.readInt();

    // now parse our path name to get our path

    lastSlash = pathName.lastIndexOf('/');
    path = pathName.substring(0, lastSlash);
    
    // and take our leaf's name

    name = pathName.substring(lastSlash + 1);

    // and get our parent

    this.parent = parent;

    count = in.readInt();

    if (false)
      {
	System.err.println("DBBaseCategory.receive(): reading in " + count + " subcategories");
      }

    for (int i = 0; i < count; i++)
      {
	addNode(new DBBaseCategory(store, in), false, false);
      }
    
    resort();
  }

  /**
   *
   * Returns the full path to this category, with levels
   * in the hierarchy separated by '/'s.
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public String getPath()
  {
    if (parent != null)
      {
	return parent.getPath() + "/" + name;
      }
    else
      {
	return "/" + name;
      }
  }

  /**
   *
   * Returns the name of this category.
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public String getName()
  {
    return name;
  }

  /**
   *
   * Gets the order of this node in the containing category
   *
   * @see arlut.csd.ganymede.CategoryNode
   *
   */

  public int getDisplayOrder()
  {
    return displayOrder;
  }

  /**
   *
   * Sets the name of this node.  The name must not include a '/'
   * character, but all other characters are acceptable.
   *
   * @see arlut.csd.ganymede.CategoryNode
   *
   */

  public boolean setName(String newName)
  {
    if (newName == null)
      {
	throw new IllegalArgumentException("DBBaseCategory can't have null name");
      }

    if (newName.indexOf('/') != -1)
      {
	throw new IllegalArgumentException("DBBaseCategory name can't include /");
      }

    if (parent != null)
      {
	if (!newName.equals(name))
	  {
	    if (parent.contains(newName))
	      {
		throw new IllegalArgumentException("DBBaseCategory name conflicts with existing name in this category");
	      }
	  }
      }

    this.name = newName;

    return true;
  }

  /**
   *
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public void setDisplayOrder(int val)
  {
    displayOrder = val;
  }

  /**
   *
   * This method returns the category that this
   * category node belongs to.
   *
   * @see arlut.csd.ganymede.Category
   * @see arlut.csd.ganymede.CategoryNode
   *
   */

  public Category getCategory()
  {
    return parent;
  }

  /**
   *
   * This method tells the CategoryNode what it's containing
   * category is.
   *
   * @see arlut.csd.ganymede.CategoryNode
   *
   */

  public void setCategory(Category category)
  {
    DBBaseCategory cat;
    String path;

    /* -- */

    if (category == null)
      {
	parent = null;
	return;
      }

    if (!(category instanceof DBBaseCategory))
      {
	// we need a local reference

	try
	  {
	    path = category.getPath();
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("couldn't get path of remote category: " + ex);
	  }

	if (debug)
	  {
	    System.err.println("** Attempting to find local copy of category " + path);
	  }

	if (editor == null)
	  {
	    cat = store.getCategory(path);
	  }
	else
	  {
	    cat = editor.getCategory(path);
	  }

	if (cat == null)
	  {
	    throw new RuntimeException("setCategory: couldn't find local parent category");
	  }

	parent = cat;
      }
    else
      {
	parent = (DBBaseCategory) category;
      }
  }

  /**
   *
   * sort the elements according to display order
   *
   */

  synchronized void resort()
  {
    new VecQuickSort(contents, 
		     new arlut.csd.Util.Compare()
		     {
		       public int compare(Object a, Object b)
			 {
			   CategoryNode aN, bN;

			   aN = (CategoryNode) a;
			   bN = (CategoryNode) b;

			   try
			     {
			       if (aN.getDisplayOrder() < bN.getDisplayOrder())
				 {
				   return -1;
				 }
			       else if (aN.getDisplayOrder() > bN.getDisplayOrder())
				 {
				   return 1;
				 }
			       else
				 {
				   return 0;
				 }
			     }
			   catch (RemoteException ex)
			     {
			       throw new RuntimeException("caught remote exception " + ex);
			     }
			 }
		     }
		     ).sort();
  }

  /**
   *
   * This method is used to place a Category Node under us.  The node
   * will be placed according to the node's displayOrder value, if resort
   * and/or adjustNodes are true.
   *
   * addNode() places the new node in the list according to the node's
   * displayOrder value.
   *
   * @param node Node to place under this category
   * @param sort If true, the nodes under this category will be resorted after insertion
   * @param adjustNodes If true, the nodes under this category will have their displayOrder recalculated.
   * this should not be done lightly, and not at all if any more nodes with precalculated or saved
   * displayOrder's are to be later inserted.
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public synchronized void addNode(CategoryNode node, boolean sort, boolean adjustNodes)
  {
    int
      i,
      index = -1;

    boolean found = false;

    CategoryNode
      cNode;

    /* -- */

    if (debug)
      {
	System.err.println("DBBaseCategory<" + getName() + ">.addNode(" + 
			   node + "," + sort + "," + adjustNodes +")");
      }

    if (node == null)
      {
	throw new IllegalArgumentException("Can't add a null node");
      }

    try
      {
	if (this.contains(node.getName()))
	  {
	    throw new IllegalArgumentException("Can't add this node.. name already registered " + node.getName());
	  }
      }
    catch (RemoteException ex)
      {
	throw new RuntimeException("caught remote " + ex);
      } 

    // find our insertion point

    if (debug)
      {
	System.err.println("DBBaseCategory.addNode(): searching to see if node is already in this category");
      }

    for (i = 0; !found && i < contents.size(); i++)
      {
	cNode = (CategoryNode) contents.elementAt(i);

	try
	  {
	    if (cNode.getName().equals(node.getName()))
	      {
		found = true;
	      }
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("Couldn't check node name: " + ex);
	  }
      }

    if (found)
      {
	throw new IllegalArgumentException("can't add a node that's already in the category");
      }

    // put our node into our content list

    // if adjustNodes is false, we're just going to add this node to the
    // end of our category list.

    if (!adjustNodes)
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.addNode(): adjustNodes is false");
	  }

	// note that we *don't* want to put in a rmi stub here for Bases
	// here.. we'd much rather have the full-access local object so
	// that we can do full direct DBObjectBase operations as the
	// category tree is managed by the Schema editor.

	if (node instanceof Base)
	  {
	    if (debug)
	      {
		System.err.println("DBBaseCategory.addNode(): inserting base");
	      }

	    DBObjectBase testBase = getBaseFromBase((Base) node);

	    if (testBase != null)
	      {
		node = testBase;
	      }
	    else
	      {
		// node should always be DBObjectBase, since the RMI
		// system converts a remote ref back into a local
		// ref.. of some kind.. ;-(

		if (debug)
		  {
		    System.err.println("DBBaseCategory.addNode(1): couldn't find base in hash.. casting ?remote?");
		  }

		if (node instanceof DBObjectBase)
		  {
		    testBase = (DBObjectBase) node;
		  }
	      }

	    if (debug)
	      {
		if (testBase.editor == null)
		  {
		    System.err.println("DBBaseCategory(" + getName() + 
				       ").addNode(1): hey!  node " + testBase.getName() + " is a null-editor!");
		  }
	      }

	    if (node != null)
	      {
		contents.addElement(node);
	      }
	  }
	else
	  {
	    // something else.. presumably a Category

	    contents.addElement(node);
	  }
      }
    else
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.addNode(): adjustNodes is true");
	  }

	try
	  {
	    if (node instanceof Base)
	      {
		if (debug)
		  {
		    System.err.println("DBBaseCategory.addNode(): inserting base");
		  }
	    
		DBObjectBase newBase = getBaseFromBase((Base) node);

		if (newBase == null)
		  {
		    if (debug)
		      {
			System.err.println("DBBaseCategory.addNode(2): couldn't find base in hash.. casting ?remote?");
		      }

		    newBase = (DBObjectBase) node;
		  }

		if (newBase == null)
		  {
		    throw new NullPointerException("null newBase in addNode! " + 
						   ((editor == null) ? "local" : "remote"));
		  }

		if (contents == null)
		  {
		    throw new NullPointerException("null contents in addNode!");
		  }

		if (debug)
		  {
		    if (newBase.editor == null)
		      {
			System.err.println("DBBaseCategory(" + getName() + 
					   ").addNode(2): hey!  node " + newBase.getName() + " is a null-editor!");
		      }
		  }

		if (newBase.getDisplayOrder() >= contents.size())
		  {
		    contents.addElement(newBase);
		  }
		else
		  {
		    contents.insertElementAt(newBase, newBase.getDisplayOrder());
		  }
	      }
	    else if (node instanceof Category)
	      {
		if (debug)
		  {
		    System.err.println("DBBaseCategory.addNode(): inserting Category");
		  }
	    
		// presumably we've got a Category here..

		if (node.getDisplayOrder() >= contents.size())
		  {
		    contents.addElement(node);
		  }
		else
		  {
		    contents.insertElementAt(node, node.getDisplayOrder());
		  }
	      }
	    else
	      {
		throw new IllegalArgumentException("don't recognize node");
	      }
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("couldn't get node display order for in-order insertion: " + ex);
	  }
      }

    // sort the elements according to display order

    if (sort)
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.addNode(): resorting category nodes");
	  }

	resort();
      }

    if (adjustNodes)
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.addNode(): adjusting category node display orders");
	  }

	for (i = 0; i < contents.size(); i++)
	  {
	    cNode = (CategoryNode) contents.elementAt(i);

	    try
	      {
		cNode.setDisplayOrder(i);
	      }
	    catch (RemoteException ex)
	      {
		throw new RuntimeException("this should not happen " + ex);
	      }
	  }
      }

    // tell the node who's its daddy

    try
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.addNode(): setting category for node");
	  }

	node.setCategory(this);
      }
    catch (RemoteException ex)
      {
	throw new RuntimeException("caught remote exception " + ex);
      }
  }

  /**
   *
   * This method can be used to move a Category from another Category to this Category,
   * or to move a Category around within this Category.
   *
   * @param catPath the fully specified path of the node to be moved
   * @param displayOrder where to place this node within this category.
   *
   * @see arlut.csd.ganymede.Category
   */

  public synchronized void moveCategoryNode(String catPath, int displayOrder)
  {
    DBBaseCategory categoryNode = editor.getCategory(catPath);
    DBBaseCategory oldCategory = (DBBaseCategory) categoryNode.getCategory();

    if (debug)
      {
	System.err.println("DBBaseCategory.moveNode(" + catPath + "," + displayOrder + ")");
      }

    if (oldCategory == this)
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.moveNode(): moving node within category");
	  }

	contents.removeElement(categoryNode);
      }
    else
      {
	if (debug)
	  {
	    System.err.println("DBBaseCategory.moveNode(): moving node from " + 
			       oldCategory.getPath() + " to " + getPath());
	  }

	try
	  {
	    oldCategory.removeNode(categoryNode);
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("Local category threw a remote exception.. ? " + ex);
	  }
      }

    categoryNode.setCategory(this);

    if (displayOrder >= contents.size())
      {
	contents.addElement(categoryNode);
      }
    else
      {
	contents.insertElementAt(categoryNode, displayOrder);
      }

    if (debug)
      {
	System.err.println("DBBaseCategory.moveNode(): adjusting category node display orders");
      }
    
    for (int i = 0; i < contents.size(); i++)
      {
	CategoryNode cNode = (CategoryNode) contents.elementAt(i);
	
	try
	  {
	    cNode.setDisplayOrder(i);
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("this should not happen " + ex);
	  }
      }
  }

  /**
   *
   * This method is used to remove a Category Node from under us.
   *
   * Note that removeNode assumes that it can recalculate the
   * displayOrder values for other nodes in this category.  This
   * method should not be called if other nodes with prefixed
   * displayOrder values are still to be added to this category, as
   * from the DBStore file.
   *
   * @see arlut.csd.ganymede.Category
   * 
   */

  public synchronized void removeNode(CategoryNode node) throws RemoteException
  {
    int
      i,
      index = -1;

    /* -- */

    if (node == null)
      {
	throw new IllegalArgumentException("Can't remove a null node");
      }

    // find our deletion point

    if (debug)
      {
	Ganymede.debug("DBBaseCategory (" + getName() + ").removeNode(" + node + ")");
      }

    for (i = 0; i < contents.size(); i++)
      {
	if (debug)
	  {
	    Ganymede.debug(" examining: " + contents.elementAt(i));
	  }

	if (contents.elementAt(i).equals(node))
	  {
	    index = i;
	  }
      }

    if (index == -1)
      {
	throw new IllegalArgumentException("can't delete a node that's not in the category");
      }

    // remove our node from our content list

    contents.removeElementAt(index);

    // now pull up the other nodes.. note that we assume that when
    // removeNode is called, no nodes will be added with stored
    // displayOrder's from a DBStore file, say.

    for (i = index; i < contents.size(); i++)
      {
	( (CategoryNode) contents.elementAt(i)).setDisplayOrder(i);
      }

    // tell our node what it's display order is.

    node.setDisplayOrder(0);

    if (debug)
      {
	if (node instanceof DBObjectBase)
	  {
	    DBObjectBase base = (DBObjectBase) node;

	    if (base.editor == null)
	      {
		System.err.println("DBBaseCategory.removeNode(): " + base.getName() + " has a null editor!");
	      }
	    else
	      {
		System.err.println("DBBaseCategory.removeNode(): " + base.getName() + " has a non-null editor!");
	      }
	  }
      }

    // Sorry, kid, yer on your own now!

    node.setCategory(null);
  }

  /**
   *
   * This method is used to remove a Category Node from under us.
   *
   * Note that removeNode assumes that it can recalculate the
   * displayOrder values for other nodes in this category.  This
   * method should not be called if other nodes with prefixed
   * displayOrder values are still to be added to this category, as
   * from the DBStore file.
   *
   * @see arlut.csd.ganymede.Category
   * 
   */

  public synchronized void removeNode(String name) throws RemoteException
  {
    int
      i,
      index = -1;

    CategoryNode 
      node = null;

    /* -- */

    if (name == null)
      {
	throw new IllegalArgumentException("Can't remove a null name");
      }

    // find our deletion point

    if (debug)
      {
	Ganymede.debug("DBBaseCategory (" + getName() + ").removeNode(" + name + ")");
      }

    for (i = 0; i < contents.size() && (index == -1); i++)
      {
	if (debug)
	  {
	    Ganymede.debug(" examining: " + contents.elementAt(i));
	  }

	node = (CategoryNode) contents.elementAt(i);

	try
	  {
	    if (node.getName().equals(name))
	      {
		index = i;
	      }
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("caught remote: " + ex);
	  }
      }

    if (index == -1)
      {
	throw new IllegalArgumentException("can't delete a name that's not in the category");
      }
    else if (debug)
      {
	System.err.println("DBBaseCategory.removeNode(): found node " + node);
	
	if (node instanceof DBObjectBase)
	  {
	    System.err.println("DBBaseCategory.removeNode(): node is DBObjectBase");
	  }
	else if (node instanceof Base)
	  {
	    System.err.println("DBBaseCategory.removeNode(): node is Base");
	  }
	else if (node instanceof DBBaseCategory)
	  {
	    System.err.println("DBBaseCategory.removeNode(): node is DBBaseCategory");
	  }
	else if (node instanceof Category)
	  {
	    System.err.println("DBBaseCategory.removeNode(): node is Category");
	  }
	else
	  {
	    System.err.println("DBBaseCategory.removeNode(): node is <unrecognized>");
	  }
      }

    // remove our node from our content list

    contents.removeElementAt(index);

    // now pull up the other nodes.. note that we assume that when
    // removeNode is called, no nodes will be added with stored
    // displayOrder's from a DBStore file, say.

    for (i = index; i < contents.size(); i++)
      {
	((CategoryNode) contents.elementAt(i)).setDisplayOrder(i);
      }

    // tell our node what it's display order is.

    // XXX why?

    node.setDisplayOrder(0);

    if (debug)
      {
	if (node instanceof DBObjectBase)
	  {
	    DBObjectBase base = (DBObjectBase) node;

	    if (base.editor == null)
	      {
		System.err.println("DBBaseCategory.removeNode(2): " + base.getName() + " has a null editor!");
	      }
	    else
	      {
		System.err.println("DBBaseCategory.removeNode(2): " + base.getName() + " has a non-null editor!");
	      }
	  }
      }

    // Sorry, kid, yer on your own now!

    node.setCategory(null);
  }

  /**
   *
   * Returns a subcategory of name <name>.
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public CategoryNode getNode(String name)
  {
    CategoryNode candidate;

    /* -- */

    for (int i = 0; i < contents.size(); i++)
      {
	candidate = (CategoryNode) contents.elementAt(i);
	
	try
	  {
	    if (candidate.getName().equals(name))
	      {
		return candidate;
	      }
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("caught remote: " + ex);
	  }
      }

    return null;
  }

  /**
   *
   * Returns child nodes
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public synchronized Vector getNodes()
  {
    return (Vector) contents.clone();
  }

  /**
   *
   * This creates a new subcategory under this category,
   * with displayOrder after the last item currently in the
   * category.  This method should only be called when
   * there are no nodes left to be added to the category
   * with prefixed displayOrder values.
   *
   */

  public Category newSubCategory(String name)
  {
    DBBaseCategory bc;

    try
      {
	bc = new DBBaseCategory(store, name, this);
      }
    catch (RemoteException ex)
      {
	return null;
      }

    bc.setDisplayOrder(contents.size() + 1);
    addNode(bc, false, true);

    return bc;
  }


  /**
   *
   * This creates a new subcategory under this category,
   * with displayOrder after the last item currently in the
   * category.  This method should only be called when
   * there are no nodes left to be added to the category
   * with prefixed displayOrder values.
   *
   * @see arlut.csd.ganymede.Category
   * 
   */

  public Category newSubCategory()
  {
    DBBaseCategory bc;
    String name;
    int i;

    /* -- */

    name = "New Category";

    i = 2;

    while (getNode(name) != null)
      {
	name = "New Category " + i++;
      }

    try
      {
	bc = new DBBaseCategory(store, name, this);
      }
    catch (RemoteException ex)
      {
	return null;
      }

    bc.setDisplayOrder(contents.size() + 1);
    addNode(bc, false, true);

    return bc;
  }

  /**
   *
   * This method returns true if this
   * is a subcategory of cat.
   *
   * @see arlut.csd.ganymede.Category
   *
   */

  public boolean isUnder(Category cat)
  {
    if (cat == null)
      {
	return false;
      }

    if (cat.equals(this))
      {
	return true;
      }

    if (parent == null)
      {
	return false;
      }
    else
      {
	return parent.isUnder(cat);
      }
  }

  /**
   *
   * This method returns true if this category directly
   * contains a CategoryNode with name &lt;name&gt;
   *
   */

  public synchronized boolean contains(String name)
  {
    CategoryNode node;

    /* -- */

    for (int i = 0; i < contents.size(); i++)
      {
	node = (CategoryNode) contents.elementAt(i);

	try
	  {
	    if (node.getName().equals(name))
	      {
		return true;
	      }
	  }
	catch (RemoteException ex)
	  {
	    throw new RuntimeException("caught remote: " + ex);
	  }
      }

    return false;
  }

  /**
   *
   * This method returns a reference to the top of this category's
   * tree.
   *
   */

  public DBBaseCategory getRoot()
  {
    DBBaseCategory node = this;

    while (node.parent != null)
      {
	node = node.parent;
      }

    return node;
  }

  /**
   *
   * This method is used to convert an RMI remote reference
   * to a Base object to a reference to the local copy.
   *
   * Needed for RMI under JDK 1.1.
   *
   */

  public DBObjectBase getBaseFromBase(Base base)
  {
    try
      {
	return getBaseFromKey(base.getTypeID());
      }
    catch (RemoteException ex)
      {
	return null;
      }
  }

  /**
   *
   * This method is used to convert an RMI remote reference
   * to a Base object to a reference to the local copy.
   *
   * Needed for RMI under JDK 1.1.
   *
   */

  public DBObjectBase getBaseFromKey(short id)
  {
    if (editor != null)
      {
	return (DBObjectBase) baseHash.get(new Short(id));
      }
    else
      {
	return store.getObjectBase(id);
      }
  }
}
